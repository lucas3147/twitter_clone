					### SECTION 8 JAVASCRIPT ###

					AULA: CASTING DE TIPOS, TOSTRING(), PARSEINT() E PARSEFLOAT()

Geralmente os advindos do browser estão em formato de string. O que pode ter um impacto muito grande em nossas aplicações caso isso não seja tratado.

parseInt() - Converte uma string ou um tipo de dado em em um inteiro.

parseFloat() - Converte um tipo de dado em um número real. Ele preserva a fração de um determinado número.

toString() - Transforma um valor numérico para um string.

Exemplo:

	var variavel1 = 10
        	var variavel2 = 20

        	variavel1 = variavel1.toString()
        	variavel2 = variavel2.toString()

        	document.write(variavel1 + variavel2)


					AULA: OPERADOR TERNÁRIO

Sintaxe:

condition ? expr1 : expr2 

variavel = condition ? expr1 : expr2 


					AULA: SWITCH NA PRÁTICA

Sintaxe:

const expr = 'Papayas';
switch (expr) {
  case 'Oranges':
    console.log('Oranges are $0.59 a pound.');
    break;
  case 'Mangoes':
  case 'Papayas':
    console.log('Mangoes and papayas are $2.79 a pound.');
    // expected output: "Mangoes and papayas are $2.79 a pound."
    break;
  default:
    console.log(`Sorry, we are out of ${expr}.`);
}



					AULA: FUNÇÕES - FLEXIBILIDADE DE PARÂMETROS

Uma das características do Javascript é a flexibilidade de parãmetros que podemos passar para uma determinada função. Isso implica dizer que mesmo que nós passe parâmetros para a função no momento da criação, nós não necessariamente precisamos passa-lo quando estamos instanciando essa função.

Em Java e php por exemplo, uma vez criado parâmetros em uma respectiva ordem, quando vamos chamar essa função, precisamos criar parâmetros com a mesma quantidade e na mesma ordem na qual a função foi criada.

Em javascript nós temos um pouco mais de flexibilidade em termos de quantidade.

function soma(a, b) {
            return a + b
        }

        console.log(soma(7, 7))
        console.log(soma(7, 7, 9, 15)) // desconsidera os parâmetros adicionis
        console.log(soma(7)) // A segunda variável será considerada como undefined O resultado aqui seria not at number.

resultado no console

14
14

// Ou seja, os parâmetros a mais que foram passados são descaratados. Já se passamos poucos parâmetros na sua instânci, os valores serão considerados omo undefined.



					AULA: FUNÇÕES ANÔNIMAS

Funções anônimas são funções que não possuem nome. O seu funcionamento é idêntico ao nome de uma função comum, porém não possui nome.

Mas se a função não tem nome como é que eu vou chamar essa função?

	É aí que entra  conceito de wrapper.
	O Javascript tem um recurso interessante que é a capacidade de armazenr em variáveis não apenas strings ou valores numéricos, mas também funções.

Exemplo:

var exibirSaudacao = function (nome) {
            document.write('Olá ' + nome + ', tudo bem?')
        }

        exibirSaudacao('Lucas')

// exibirSaudacao() passa a ser uma referência para a função anônima, o que significa que a partir de agora ela é um 'embrulho' dessa determinad função.


Wrapper

	Técnica de embrulhar funções utilizando variáveis.


Esses recursos são fortemente utilizando no javascript, isso porque o javascript adota um conceito de utlização de funções de callback, que nada mais é do que a passagem de parâmetros de funções para outras funções.



					AULA: FUNÇÕES DE CALLBACK

Funções de callback nada mais é do que passar parãmetros de funções para outras funções.

EXEMPLO:

callbackSucesso(titulo, descricao); 	// Função

callbackErro(erro);			// Função

function exibirArtigo (id, callbackSucesso, callbackErro) {

	// Lógica para recuperar o artigo com base no id

if (?) {
	callbackSucesso('Titulo', Descrição')
} else {
	callbackErro('Erro');
}

}

Prática:

        function exibirArtigo(id, callbackSucesso, callbackErro) {
            // lógica: recurperar o id via requisisção http
            if (true) {
                callbackSucesso('Funções de callback em JS)', 'Funções de callback são muito utilizadas...')
            } else {
                callbackErro('Erro ao recuperar os dados');
            }
        }

        var callbackSucesso = function() {

        }

        var callbackErro = function() {

        }

        exibirArtigo(1, callbackSucesso, callbackErro)

	// Repare que utilizamos a técnica de wrapper para economizar tanto linhas de código e tornando fácil a mautenção do código.

	
					AULA: FUNÇÕES PARA MANIPULAR STRINGS

Propriedades Length
	
	Converte um texto em um objeto e retorna  a quantidade de caracteres dentro dela.

	document.write('Jorge Sant Ana'.length)		// 14

charAt()

	Retorna a posição de um caractere dentro da cadeia de caracteres. Nós informamos um determinado índice e a função retorna o caractere daquele respectivo índice.

	document.write('Jorge Sant Ana'.charAt(7))		// a

indexOf()

	Informamos um caractere e a função retorna a posição daquele determinado caractere. Caso tenha dois caracteres iguais, será pegado a posição do primeiro caractere informado.

	var nome = 'Jorge Sant Ana'
       	document.write(nome.indexOf('a'))		// 7

	Caso não tenha o caraactere naquela string, será informado o -1.

Replace()

	Substitui textos dentro de uma string.		
	document.write(nome.replace('Sant Ana', 'Silva'))	// Jorge Silva

substr()

	Recorta uma parte da string. Indico a posição inicial e a quantidade de caracteres que eu quero pegar na sequência.
	document.write(nome.substr(6, 4))		// Sant

toUpperCase()

	Converte os caaracteres para a caixa alta

toLowerCase()

	Converte os caracteres para a caixa baixa.

trim()

	Remove os espaços em braco das extremidades da string.

	var nome = ' Jorge Sant Ana '
        	document.write('-' + nome.trim() + '-')		// -Jorge Sant Ana-


						AULA: FUNÇÕES NATIVAS PARA MANIPULAR TAREFAS MATEMÁTICAS


As funções nativas utilizam o objeto nativo do javascript chmado Math.

ceil

	Arredonda um valor decimal para cima. 10.5 vira 11

	var x = Math.ceil(10.380)

        	document.write(x);		// 11

floor

	Arredonda o valor decimal para baixo. 10.5 vira 10

	var x = Math.floor(10.380)

        	document.write(x);		// 10

round

	Se um valor decimal 10.4 ele arredonda para baixo. Se o valor for 10.55 ele arredonda para cima.

	        	var x = Math.round(10.580)

        		document.write(x);	// 11

	        	var x = Math.round(10.380)

        		document.write(x);	// 10

random

	Fornece um número aleatório.

	        	var x = Math.random()

       	 	document.write(x);

						AULA: FUNÇÕES NATIVAS PARA MANIPULAR DATAS

getDay()

	Pega o dia gravado no sistema operacional

getMonth()

	Pega o mês gravado no sistema operacional. Atenção, janeiro é interpretado como 0 e dezembro 11.

getFullYear()

	Pega o ano gravado no sistema operacional.


					AULA: PRATICANDO UM POUCO MAIS COM DATAS

getTime()

	Recupera os milisegundos de 1 de janeiro de 1970 até a data em questão.

Math.abs()

	Retorna um valor absoluto.


Adicionar ou remover dias de uma data:

        var data = new Date()

        //adicionando / removendo dias
        document.write(data.toString())
        data.setDate(data.getDate() + 1)
        document.write('<hr>')
        document.write(data.toString())
        document.write('<hr>')

        //adicionando / removendo meses
        document.write(data.toString())
        data.setMonth(data.getMonth() + 1)
        document.write('<hr>')
        document.write(data.toString())
        document.write('<hr>')

        //adicionando / removendo anos
        document.write(data.toString())
        data.setFullYear(data.getFullYear() + 1)
        document.write('<hr>')
        document.write(data.toString())

Cálculo entre duas datas diferentes:

        // Converter datas para algo que possamos calcular

        document.write(data1.getTime())
        document.write('<hr>')
        document.write(data2.getTime())
        document.write('<hr>')

        // encontrar a quantidade de milisegundos entre data1 e data2
        var milisegundos_entre_datas = Math.abs(data1.getTime() - data2.getTime())
        document.write(milisegundos_entre_datas);


        document.write('<hr>')

        // descobrir quantos dias existem naqueles milisegundos
        document.write('1 dia tem: ' + (1 * 24 * 60 * 60 * 1000) + ' milisegundos')
        document.write('<hr>')

        // imprimir a divisão da diferença de milisegundos entre as datas pelos milisegundos existentes em um dia
        var milisegundos_por_dia = (1 * 24 * 60 * 60 * 1000)
        document.write('A diferença entre a data1 e a data2 é de ' + Math.ceil(milisegundos_entre_datas / milisegundos_por_dia) + ' dias')


					AULA: EVENTOS DO MOUSE

onClick

	É acionado quando o elemento é clicado

ondblClick

	É acionado que clicamos num determinado elemento duas vezes

onMouseUp

	É  acionado quando o click em um determinado elemento é liberado

onMouseOver

	É acionado quando o cursor do mouse sobrepôe o elemento

onMouseOut

	É acionado quando o cursor do mouse sai da região página ocupada pelo elemento.

Alguns elementos html não tem suporte para determinados eventos, visite o site w3schools.


					AULA: EVENTOS DO TECLADO

onkeydown

	É acionado a partir do momento em que uma tecla é clicada

onkeypress

	É acionado no momento em que uma tecla é pressionada. Apenas irá funcionar em teclas que representam um caractere. O ctrl não acontece

onkeyup

	É acionado quando uma teclado pressionada é solta.

					AULA: EVENTOS DE JANELA

Esses eventos estão relacionados à manipulação das nossas páginas html. Por isso o elemento que sofre essa alteração é o body.

onresize

	É acionado quando o frame / página ela é redimensionada. Aumentado ou diminuindo.

onscroll

	É acionado quando o scroll do mouse é acionado.

Para ver os eventos relacionados a esse grupo vá na página w3schools na parte de frames / events


					AULA: EVENTOS DE FORMULÁRIOS

onfocus

	É acionado quando o elemento recebe o focu do cursor do mouse.

onblur

	É acionado quando o elemento perde o focu.

onchange

	É acionado quando o estado do elemento é modificado.


					AULA: DOM PARTE 1 - INTRODUÇÃO

O que é DOM?

Document Object Model

API que permite o acesso via JavaScript a todos os elementos HTML que fazem parte da nossa página.

Todo o conteúdo do HTML é escrito através de tags. As tags encapsulam conteúdos, esses conteúdos podem ser outras tags, chamadas de tags filhas, ou podem ser textos.

Todos os elementos HTML quando interpretados pelo navegador, ficam organizados num objeto document. Sendo que essa organização serve como uma interpretação análoga ao de uma árvore

Os elementos pais cápsula ou os elementos filhos de modo a estabelecer trajetos bem específicos para alcançar cada um dos elementos que constituem a página.

Cada elemento contitudo no DOM é chamado de nó / node.


					AULA: DOM PARTE 2 - SELECIONANDO ELEMENTOS DA PÁGINA

Métodos para selecionar elementos da página

getElementById()

getElementsByTagName()

getElementByClassName()

getElementByName()

	Todos os outros foram interpretados e retornados como consulta como um html collection. Nesse caso o retorno é um NodeList []

					AULA: DOM PARTE 4 - MANIPULANDO ESTILOS DE ELEMENTOS

Podemos modificar aspectos visuais da nossa página a partir do objeto 'style' da nossa página.

Exemplo da função que criamos nessa página.

function modificaEstilo(corDeFundo) {

            document.getElementById('quadrado').style.background = corDeFundo
        }

No exemplo clicamos num determinado botão, e ele chama uma função passando uma cor por parâmetro.


					AULA: DOM PARTE 5 - MANIPULANDO CLASSES DE ELEMENTOS

Vamos selecionar o elemento desejado e na sequência através do atributo className vamos aplicar uma classe, que representa o estilo visual, o resultado disso, é a modificação visual de um elemento, baseado num atributo class.


					AULA: APP CALCULADORA PARTE 2 - IMPLEMENTANDO A LÓGICA DO CÁLCULO

Nessa aula foi ressaltado uma função nativa d Javascript muito importante chamada de eval()


eval()

	Ela faz o seguinte: Nós submetemos um parâmetro que é uma string, e ela interpreta essa string como sendo uma instrução javascript. É ccomo se nós pegássemos a nossa string e submetêssemos para o interpretador do javascript.

					AULA: ARRAY MULTIDIMENSIONAL

CÓDIGO DE AULA:

<script>
        var lista_coisas = Array()

        lista_coisas['frutas'] = Array('Banana', 'Maçâ', 'Morango', 'Uva')

        lista_coisas['pessoas'] = []

        lista_coisas['pessoas']['a'] = 'João'
        lista_coisas['pessoas']['b'] = 'Maria'
        lista_coisas['pessoas']['c'] = 'José'


        console.log(lista_coisas)
</script>

					AULA: ARRAY - MÉTODOS DE INCLUSÃO E EXCLUSÃO DE ELEMENTOS

Incluir elemento no final do array

push()

	lista_frutas.push('Uva')

Incluir elemento no começo do array

unshift()

	lista_frutas.unshift('Uva')

excluir elemento do final do array

pop()

	lista_frutas.pop()

excluir elemento no começo do array

shift()

	lista_frutas.shift()


					AULA: ARRAY - MÉTODOS DE ORDENAÇÃO

sort()

	Faz uma reordenação alfanumérica com base nos valores dos elementos de um array, ajustando inclusive os seus respectivos índices. Mas ele e específico para valores alfanuméricos, um array de números pode quebrar a aplicação.

	var lista_frutas = Array()

        	lista_frutas[0] = 'Maçã'
        	lista_frutas[1] = 'Uva'
        	lista_frutas[2] = 'Banana'
        	lista_frutas[3] = 'Morango'

	console.log(lista_frutas.sort())

	// resultado:

	0: "Banana"
	1: "Maçã"
	2: "Morango"
	3: "Uva"

-------------------------------------------------------

	// valores não alfa numéricos

	var lista_frutas = Array()

        	lista_frutas[0] = 12
        	lista_frutas[1] = 40
        	lista_frutas[2] = 3
        	lista_frutas[3] = 7
       	lista_frutas[4] = 19
        	lista_frutas[5] = 1

	console.log(lista_frutas.sort())

	// resultado:

	0: 1
	1: 12
	2: 19
	3: 3
	4: 40
	5: 7

	// repare que o 1, 12, 19 estão vindo antes do 3, justamente pelo método entender que que o primeiro valor 1 é menor que o 3, e assim ele ordena, mais não leva em conta as próximas casas decimais. É por isso que devemos "ensinar ao método sort a trabalhar com essa situação, para fazer isso bem simples, basta nós passar uma função por parãmetro que indique como os valores são ordenados:

	var lista_frutas = Array()

        	lista_frutas[0] = 12
        	lista_frutas[1] = 40
        	lista_frutas[2] = 3
        	lista_frutas[3] = 7
        	lista_frutas[4] = 19
        	lista_frutas[5] = 1

        	console.log(lista_frutas.sort(ordenaNumeros))

        	function ordenaNumers(a, b) {
            		return a - b
		// < 0 = a ordena antes de b
		// > 0 = b ordenado antes de a
		// == a ordem é mantida
        	}

	// Mais um exemplos de função de callback.

	// Além disso repare a característica de parâmetro variável também neste caso, a ausência da função de callback implica no comportamento padrão que é a ordenação alfabética.

	// Importante: mesmo que os valores desse array sejam strings que representam números, não tem problema, por que o javascript faz o casting e converte automaticamente para os valores corretos.


					AULA: PRATICANDO UM POUCO - PERCORRENDO E LISTANDO ITENS DE ARRAYS

CÓDIGO DE AULA:

        var lista_frutas = Array()

        lista_frutas[0] = 'Banana'
        lista_frutas[1] = 'Maçã'
        lista_frutas[2] = 'Morango'
        lista_frutas[3] = 'Uva'

        console.log(lista_frutas.length)
        var y = 0

        while (y < lista_frutas.length) {
            document.write(lista_frutas[y] + '<br>')

            y++
        }

					AULA: PRATICANDO UM POUCO - CRIANDO UMA TABUADA DE 1 A 10

CÓDIGO DE AULA:

<script>

        for (var y = 1; y <= 10; y++) {
            for (var x = 1; x <= 10; x++) {
                document.write(y + ' x ' + x + ' = ' + (y * x) + '<br>')
            }
            document.write('<hr>')
        }


</script>

					AULA: ESTRUTURA DE REPETIÇÃO PARTE 5 - FOR IN

O forin é uma estrutura de repetição feita pra iterar um número de vezes contido dentro um array. Isso significa que se o array tem 10 elementos, utilizando essa estrutura de repetição, será repetido um trecho de código 10 vezes. O forin foi feito exclusivamente para listar valores de array, a sua sintaxe é mais curta que a do foreach, obtendo o valor apenas o índice de cada elemento contido num array.

A sua importância se dá principalmente quando queremos listar arrays em que os seus índices não são sequenciais, são aleatórios, podendo ter strings e valores numéricos. Ou seja, não poderiamos percorrer esses índices utilizando estruturas de repetições simples, em que as variáveis são incrementadas a cada laço.

CÓDIGO DE AULA:

    <script>

        // var listaConvidados = ['Jorge', 'Jamilton', 'José', 'Ana', 'Maria']

        var listaConvidados = Array()

        listaConvidados['a'] = 'Jorge'
        listaConvidados[10] = 'Jamilton'
        listaConvidados['zebra'] = 'José'
        listaConvidados[-1] = 'Ana'
        listaConvidados[true] = 'Maria'

        console.log(listaConvidados)

        for (var x in listaConvidados) {
            console.log('índice ' + x + ' valor ' + listaConvidados[x])
        }
    </script>


					AULA: ESTRUTURA DE REPETIÇÃO PARTE 6 - FOREACH

O foreach em php por exemplo é um comando de repetição, ou seja, é um laço (um loop propriamente dito). Em JavaScript ele é uma função que fica abaixo do prototype do objeto array. Isso significa que o foreach, no contexto do javascript é aplicado a arrays, ele funciona como uma função, ele não é uma estrutura de repetição, porém, ele serve para esse propósito. E aí, ele funciona muito parecido como o forin.

No foreach temos que passar uma função de callback, que é uma função que basicamente explica para ele como que tem que atuar com os determinados índices ou valores desse respectivo array.

Essa função de callback recebe três parâmetros, que é o valor, o índice e o próprio array. Tal função é executada no contexto do foreach. Podemos então manipular os valores do índice, valor e array como quisermos.

Podemos também criar uma variável que contenha a chamada de função de callback, o que deixa o código um pouco mais legível. Desse modo, podemos passar essa mesma variáveis para outros tipos de arrays.

***Importante***

	O foreach atua apenas sobre índices com valores numéricos partindo de 0, não precisa ser sequencial, mas precisa ser valores numéricos iguais a 0 ou superiores.  Caso contrário a função desconsidera aquela posição do array.

CÓDIGO DE AULA:

    <script>

        var listaFuncionarios = ['Lucas', 'Josy', 'Gustavo', 'José', 'Thiago']

        console.log(listaFuncionarios)

        listaFuncionarios.forEach(function (valor, indice, array) {
            // lógica
            console.log('índice ' + indice + ' | valor: ' + valor)
        })

    </script>

					AULA: FUNÇÕES - TRABALHANDO COM PARÂMETROS VARIÁVEIS

Nessa aula vamos aprender a como podemos passar uma quantidade de parâmetros e do lado da função, conseguir lidar com essa quantidade indefinida de parãmetros.

Parâmetros variáveis nada mais é do que tornar os parãmetros dessa função como sendo as prórias variáveis.

Existe uma palavra reservada chamada arguments

arguments é um objeto que existe para todas as funções no javascript, contendo a relação de parâmetros passada para a função. Esse objeto (arguments) se comporta como sendo uma variável local disponível dentro da função, essa variável por sua vez, guarda todos os parâmetros passada para a função em que esse objeto se encontra. Como se trata de um objeto, não podemos tratá-lo com métodos como o pop() por exemplo, mas podemos convertê-lo para um array.

CÓDIGO DE AULA:

function soma() {
            console.log(arguments)
        }

console.log(soma())

No EcmaScript 6 existe uma outra técnica para a chamada de parâametros variáveis que vamos estudar mais a frente.

					AULA: TRATAMENTO DE ERROS COM TRY, CATCH, THROW E FINALLY

CÓDIGO DE AULA:

    <script>



        //netflix
        var video = Array()

        video[1] = Array()
        video[1]['nome'] = 'Fullmetal Alchemist'
        video[1]['categoria'] = 'Anime'

        function getVideo(video) {
            // logica
            // http
            try {
                console.log(video[0]['nome'])

            } catch (erro) {
                tratarErro(erro)
                console.log('Agora sim podemos tratar esse erro')
                throw new Error('Houve um erro mas não se preocupe, estamos trabalhando nisso agora!')
            } finally {
                console.log('Sempre passa por aqui')
            }

            console.log('A aplicação não morreu')


        }

        function tratarErro(e) {
            // lógica para registrar o erro no servidor
            console.log(e)
        }

        getVideo(video)
    </script>


					AULA: BOM PARTE 1 - WINDOW

O Window é a janela do browser onde todo o conteúdo é renderizado. Dentro do window nós temos o objeto document. Window.document que fornece o acesso aos elementos html da página.

O Window é um objeto formado pelo browser que incorpora a árvore de elementos html da página.

Esse é um objeto que podemos além de criar os elementos html, se comunicar também com os recursos do browser.

Para melhor entendimento dos métodos e atributos que podemos acessar a partir da Api BOM veja em : www.w3schools.com

					AULA: BOM PARTE 2 - SCREEN

O objeto Screen fornece acesso a atributos relativos a tela do browser.

Com o objeto screen podemos ter informações sobre a largura e a altura da parte interna do navegador. A onde os elementos HTML são renderizados.

Através desse objeto podemos tratar algumas possibilidades / decisões de renderização dentro das nossas aplicações.

Por exemplo:

	se a página for acessada a partir de um dispositivo móvel nós podemos capturar o tamanho da tela disponível para o Browser e com isso exibir um menu específico. A mesma coisa para uma versão web se a resolução for superior por exemplo a 4 nós podemos exibir algum outro tipo de menu.

métodos:

availHeight - Fornece o acesso a altura da tela do browser excluindo a barra de ferramentas.

availWidth - Fornece o acesso a largura da tela do browser excluindo a barra de ferramentas.

height - Fornece o tamanho total da altura

width - Fornece o tamanho total da largura.


					AULA: BOM PARTE 3 - LOCATION

O objeto Location fornece acesso a atributos e métodos da url atual. Ou seja, do path que estamos naquele momento.

Com o Location podemos por exemplo, forçar um redirecionamento, afetando a url da aplicação, ou mesmo podemos atualizar a página a partir do método reload.

// Quando clicamos num link por exemplo, temos que, estamos acessando recursos do objeto location e forçando o redirecionamento da página, mas tudo pode ser de forma programática.

ATRIBUTOS E MÉTODOS

	href

		seta qual a url que será retornada para o navegador.


	reload

		recarrega a página


					AULA: BOM PARTE 4 - TIMING

Podemos utilizar esses métodos para estabelecer ações que serão executadas somente dali a algum tempo. Somente após transcorrer o tempo estabelecido para a execução da ação.

setTimeout

	Executa ação uma vez após o tempo informado

	Ex:

		setTimeout(function () { document.write('Teste') }, 2000)

	clearTimeout()		// para parar

setInterval

	Sempre executa a ação após o período informado

	Ex:

		setInterval(function () { document.write('Teste') }, 2000)

	clearInterval		// para parar

CÓDIGO DE AULA:

<script>

        var i = 5

        var x = setInterval(function () {
            document.write(i)
            i--

            if (i === 0) {
                clearInterval(x)
            }
        }, 1000)
</script>

-------------------------------------------------------------------------------------------------

					### SECTION 09 ###

		AULA: COMO UTILIZAR O ECMASCRIPT 2015 (ES6) EM SUAS PÁGINAS?

- Os navegadores web não suportam as features do (ES6), por esse motivo que vamos converter o código ES6 para a sintaxe do ES5

		AULA: BABEL - INTRODUÇÃO E CONFIGURAÇÃO

- O Babel é um dos compiladores mais completos em termos de transcrição de código escrito em ES6 para ES5

-------------------------------------------------------------------------------------------------


					### SECTION 10 ###
		
		AULA: WEB STACKS MAIS CONHECIDAS NO MOMENTO


FRONT END:

	HTML

	CSS

	JAVASCRIPT

	BOOTSTRAP

	ANGULAR

	REACT

	VUE.JS

BACK - END

	NGINX ( Servidor Web )

	PHP (Linguagem de Programação )

	POSTGREE ( Banco de Dados )
	
	EXPRESS (  framework para Node.js )

	NODE.JS ( Servidor web que roda o javascript )

	APACHE ( Servidor Web )
	
	SQL SERVER ( Banco de dados )

	MYSQL ( Banco de dados)

	LARAVEL (  Framework PHP )

	MICROSOFT IIS ( Servidor Web )

	PERL (Linguagem de programação )

	PYTHON ( Linguagem de Programação )

	ASP.NET ( Linguagem de Programação )

	ORACLE ( Banco de dados )

	JAVA ( Linguagem de Programação )

	MONGO DB (Banco de Dados )

PRINCIPAIS STACKS EM ALTA NO MERCADO NO BRASIL:

WAMP - Utiliza tecnologias como

PHP - como linguagem de programação
MySQL - Como serviço para banco de dados
Apache - Como servidor Web

WIMP - Combina sistemas operacionais como o windows.

Microsoft IIS - Como servidor web
MySQL - como sistema gerenciador de banco de dados.
PHP - Como linguagem de programação da aplicação BackEnd.

WISA - Combina sistemas operacionais como o windows.

Microsoft IIS - Como servidor web
MySQL - como sistema gerenciador de banco de dados.
ASP.net - Como linguagem de programação.

MEAN

MongoDB - Sitema gerenciador de banco de dados não relacional.
Express - O framework do lado BackEnd.
Angular - O framework do lado FrontEnd.
Node.js - Servidor HTTP.


		AULA: STACK WAMPP - CONHECENDO O XAMPP

// Como temos uma máquina apenas para desenvolver aplicações web, o nosso servidor não está isolado do nosso cliente, mas como programador/estudante, temos que ter em mente que esse modelo é um modelo conceitual, mas não necessariamente precisamos ter toda a estrutura isolada para que possamos desenvolver aplicações web. Por esse motivo que precisamos de um endereço loop-back, que é uma forma de fazer requisições http para o nosso próprio computador.

// Para fazer essas requisições basta pesquisar no navegdor por 'localhost'. Esse endereço bate na placa de rede da própria máquina e faz com que a máquina responda a essa requisição.


				### PHP ###

		AULA:  EMBUTINDO BLOCOS PHP EM PÁGINAS HTML

NOME		TAG

Tag padrão	<?php código aqui?>		Habilitada

Tag de impressão	<?= código aqui ?>		Habilitada

Tag curta		<? código aqui?>		Desabilitada

*Asp tg		<% código aqui %>		Descontinuada na versão 7

// Precisamos utilizar tags  de códigos para submeter a um interpretador php de tal modo que ele retorne a interpretação desse código como sendo um conteúdo html complementar que por fim será entregue para quem fez a requisição da página.

// Podemos inserir tags php em qualquer local do html, pode ser no head, pode ser no body, até mesmo fora das tags html, o que não faria muito sentido, mas é possivel.

// No php, a utilização do ponto e vírgula no término dos nossos comandos.

// Se inspecionarmos a codificação no browser do nosso código php, as tags e códigos php não estão indexadas ao nosso documento html, como se estivessem sido desconsideradas. Mas na verdade é por que o php interpreta as suas instruções, identifica uma saída, e adiciona o seu texto como conteúdo do body da página html que é apresentada no browser. Os navegadores não tem a inteligência para interpretar a codificação php. O php precisa vir pronto do back-end para ser apresentado no browser.


		AULA: SAÍDA DA DADOS COM ECHO() E PRINT()

Os dois comandos em questão, echo e print, possuem um objetivo muito claro, que é a impressão de conteúdos advindos do bloco de códigos do php dentro do arquivo html que é entregue para o usuário.

// é importante que passamos a nossa cadeia de caractere possuir aspas duplas ou simples e ponto e vírgula

// A última intrução de código do nosso bloco php não é necessário colocar ponto e vírgula;

// Podemos adicionar códigos html dentro do aspas para o php transformar como conteúdo html.

APROFUNDAMENTO

ECHO - Construtor da linguagem php, imprime o conteúdo.

PRINT - O print inicialmente era uma função. Onde passamos parâmetros ou n parâmetros, essa função executa alguma coisa e dependendo da função pode ou não retornar um valor, o print apresenta essa característica, podendo ser escrito também:

print("Meu primeiro código php");

A função print pode ser capturada e armzenada em uma variável do tipo booleano, o valor 1 representa que a função foi bem executada. 0 representa que a função foi mal executada ou apresenta erros.

Pelo fato do print imprimir um conteúdo e na sequência retornar um valor, a sua execução se torna um pouco mais lenta que o echo, mas tal diferença é imperceptível.


		 AULA: FUNCIONAMENTO DO PHP UM POUCO MAIS A FUNDO (PÁGINAS ESTÁTICAS X DINÃMICAS)


// como o php se encaixa no contexto de aplicações web, ou seja, a onde o interpretador do php entra em ação para a produção de páginas dinâmicas?

Quando falamos de páginas estáticas, estamos falando de páginas html cujo o código já está definido, ou seja, nós apenas entregamos um arquivo html para quem fez  requisição. Mas quando falamos  de páginas dinâmicas, essa requisição é feita para um arquivo .php ou .asp em que do outro lado do servidor haverá uma linguagem de programação que vai atuar sobre essa requisição feita para o servidor. No nosso caso o apache não é o único servidor mas é um dos mais utilizados. Então o servidor recebe uma solicitação, e se por acaso essa solicitação for de um arquivo .php ele submete essa requisição para o interpretador do php, indicando qual que é o script que deve ser interpretado, esse script do php deve ser interpretado em tempo de requesição, essa interpretação produz uma página html, e o resultado dessa interpretação é anexada dentro do documento html, que por sua vez é entregue para o servidor apache de forma a resposta, essa resposta é encaminhada para quem fez essa solicitação, ou seja para o browser cliente. Por isso que ao inspecionarmos os códigos nos navegdores, não é possivel ver as codificações php, porque essa codificação entra em ação do lado do servidor, formando a página html durante esse processo de requisição e resposta.

Diferença entre páginas estáticas x dinâmicas:

Páginas estáticas possuem codificação hardcode em que o servidor http recupera essa requisição e devolve um arquivo, sem fazer tratativas dentro desse arquivo. Enquanto páginas dinâmicas são páginas produzidas num intervalo entre a requisição e a resposta que é recebida e devolvida pelo servidor http, nesse caso o apache, então nesse intervalo pode haver alguma linguagem de interpretação capaz de receer essa requisição, processar um script, formar uma página web-dinâmica e devolver essa página para o apache, para que o apache possa fazer essa ponte entre o cliente que fez essa requisição.

		AULA: INCLUINDO A TAG CURTA DO PHP

// Para incluir a tag curta é necessário que alteremos no apache dentro do xampp uma funcionalidade que agora eu não me lembro kkk.


		AULA: COMENTÁRIOS

Comentário de 1 linha

	// comentário de uma linha

Comentário de 1 linha no estilo shell

	# comentário de uma linha

Comentário de múltiplas linhas

/*
	Comentário de múltiplas linhas.
	Este tipo de comentário permite que várias
	linhas sejam comentadas ao mesmo tempo.
*/


		AULA: VARIÁVEIS - INTRODUÇÃO

O que sõ variáveis ?

Tipos de variáveis em PHP

	string, int, float, boolean, array ...

Regras para declaração de variáveis em PHP

	Deve obrigatoriamente iniciar  com o caracter "$"

	Não pode conter espaços ou caracteres especiais ( com exceção do underline )

Não requer ( ou suporte ) a definição explícita de tipo

Case sensitive

	$nome   !=   $Nome   !=   $NOME

Exemplos de variáveis válidas x inválidas

	$nome		$fone1		$endereco_2

	$ idade		$1fone		$número

		AULA: VARIÁVEIS - PRÁTICA

CÓDIGO DE AULA:

<body>
    
    <?php
        // string
        $nome = "Lucas";
    ?>

    <h1>Ficha cadastral</h1>
    <br>
    <p>Nome: <?= $nome ?></p>

</body>
// Em php, não existe uma definição explítica referindo o tipo de dado que a variável assume, o php por si só diferencia umas outras conforme atribuimos o seu valor.
// Perceba-se que para podemos referenciar a nossa variável no documento html precisamos utilizar a tag de impressão do php.
// Mas poderíamos utilizar a tag padrão do php e depois aplicar o código print ou echo para mostrar na tela.

Ex.:

    <p> Nome: <?php print $nome ?> <p>


		AULA: ALTERANDO VALORES DAS VARIÁVEIS

// Com o decorrer do nosso programa precisamos alterar essas variáveis, porém, tais variáveis devem ser alteradas em tags padrão do php diferentes, ou seja, para duas variáveis com o mesmo nome e diferente valor contido em uma tag, tal regra não é permitido.

		AULA: CONCATENAÇÃO

// O símbolo para concatenação nessa lingugem é ponto. Esse método é utilizado no caso da utilização das aspas simples.

// Aspas duplas não é necessário o símbolo para concatenação, apenas referencie com cifrão($).

// Aspas duplas se torna um pouco mais lento que a aspas simples.

		AULA: VARIAVEIS CONSTANTES

// Por que utilizar variáveis de valor es constantes?

// Ao trabalharmos com variáveis constantes, estamos fornecendo para o nosso programa uma certa segurança, pois desse modo, não deixamos com que o valor de tal variável se altere de forma indevida do nosso programa.

// Para utilizar variáveis constantes precisamos de uma função chamada define(). Na qual espera dois parâmetros, o primeiro é o nome da variável, o nome da variável é submetido para a função em formato de string, o segundo parâmetro passamos um valor para essa variável, é obrigatório a passagem de valor para variáveis constantes.

Ex.:

	define('BD_URL', ''

// Para constantes, de forma geral na programação é uma boa prática utilizar nomes de constantes em formato maiúsculas.

		AULA: CASTING E TIPOS

// Mudança de tipos de dados das variáveis.
// A função gettype() espera um parâmetro que é a variável e retorna o tipo da variável.

		AULA: FUNÇÕES NATIVAS PARA MANIPULAR STRINGS

strtolower($texto) -> Transforma todos os caracteres d string em minúsculos

strtoupper($texto) -> Transforma todos os caracteres d string em maiúsculos

ucfirst($texto) -> Transforma o primeiro caracter da string em maiúsculo

strlen($texto) -> Conta a quantidade de caracteres de uma string

str_replace(<procura por>, <substitui por>, $texto) -> Substitui uma cadeia de caracteres por outra dentro de uma string

substr($texto, <posicao inicial>, <qtde caracteres>) -> Retorna parte de uma string

		AULA: FUNÇÕES NATIVAS PARA TAREFAS MATEMÁTICAS

ceil($numero) -> Arredonda o valor para cima.

floor($numero) -> Arredonda o valor para baixo.

round($numero) -> Arredonda o valor com base nas casas decimais.

rand() -> Gera um inteiro aleatório.

sqrt($numero) -> Retorna a raiz quadrada.

		AULA: FUNÇÕES NATIVAS PARA MANIPULAR DATAS

date(formato) -> Recuperar a data atual.

date_default_timezone_get(timezone) -> Recuperar o timezone default da aplicação.

// Atualiza o tempo automaticamente

date_default_timezone_set(timezone) -> Atualizar o timezone default da aplição.

strtotime(data) -> Transformar datas textuais em segundos.

// É necessário ver a documentação do php para entender a formatação das datas

// Nessa aula, aprendemos também a como manipular as datas, ou seja, calcular soma / diferença, no entanto, é importante anotar pois, quando estamos tratando de datas, no Brasil escrver os dias / mes / ano, entretanto, ao passarmos para a função strtotime(data) resultará em erro, pois está configurado para calcular datas no formato americano ano / mes / dia, então muita atenção em relação a esse ponto.

// Strings não podem ser calculadas, ou seja, transforme a sua data em string para uma representação TimeStamp.

// O cálculo da string para TimeStamp a função calcula quantos segundos existem entre 1970, surgimento da era Unix até o ano especificado.

CÓDIGO DE AULA

<?php
    /*
    // Recuperação da data atual / data corrente
    echo date('d/m/Y H:ia');

    //dia/mes/ano horas:minutos
    echo "<br>";
    echo date_default_timezone_get();
    date_default_timezone_set('America/Sao_Paulo');
    echo "<br>";
    echo date('d/m/Y H:ia');
    */

    $data_inicial = '2018-04-24';
    $data_final = '2018-05-15';

    //timestamp
    //01/01/1970     --    2018-04-24 (js -> milisegundos / php -> segundos)

    $time_inicial = strtotime($data_inicial);
    echo  $data_inicial . '-' . $time_inical;
?>

				AULA: ARRAY BÁSICO - PRÁTICA

// Podemos debugar/fazer a impressão o nosso array de duas formas de como o nosso array está ficando

- var_dump($lista_frutas);

	var_dump informa o tipo de dado que o elemento em determinado índice representa
	informa o índice
	informa a quantidade de elementos
	Se houver strings, informa a quantidade de caracteres, vírgulas, tils, cedilha etc... Também serão contados.

- print_r($lista_frutas);

	//tais informações são um pouco mais simplificada no print_r.
	Informa o índice

- var_export($lista_frutas);

	// É tão simples quanto o print_r

// Estas funções nativas são utilizadas para debug, para ver o que está acontecendo com o array dentro do browser.

Podemos utilizar uma tag bem interessante para a formatação dos arrays do html que é a tag <pre>. Ela nos ajuda a deixar o conteúdo do array formatado

Temos dois tipos de arrays, os sequenciais e os associativos

	Os Arrays sequenciais são atribuidos os índices de seus elementos no momento da sua declaração, ou seja, é automático

	Os Arrays associativos nós definimos os índices/chaves  para cada um de seus elementos. Fazemos isso indicando um valor antes do elemento, e não separamos por vírgula, mas sim por um igual maior (=>). Nesse tipo de função, podemos informar índices tanto como strings quantos valores numéricos.

EXEMPLO:

<?php
	// sequenciais (numéricos)
	$lista_frutas = array('Banana', 'Maçã', 'Morango', 'Uva', 'Abacate');
	// $lista_frutas = ['Banana', 'Maçã', 'Morango', 'Uva', 'Abacate'];  Podemos utilizar dessa maneira ou a de cima
	$lista_frutas[] = 'Abacaxi';

	/*
	echo '<pre>';
		var_dump($lista_frutas);
	echo '</pre>';
	echo '<hr>';
	echo '<pre>';
		print_r($lista_frutas);
	echo '</pre>';
	*/

	echo $lista_frutas[2];

	// Associativos
	$lista_frutas = array(
	'a' => 'Banana', 
	'b' =>'Maçã', 
	'x' =>'Morango', 
	'z' =>'Uva', 
	'2' =>'Abacate');

	echo '<pre>';
	var_dump($lista_frutas);
	echo '</pre>';

	echo $lista_frutas['b'];
?>
				AULA: ARRAY MULTIDIMENSIONAL

Declaração de matrizes:

	Dentro do array que é a nossa matriz devemos declararmos mais arrays.

EXEMPLO:

<?php

        	//$lista_coisas = array();
        	$lista_coisas = [];

       	/*
        	$lista_coisas['frutas'] = 'Banana';
        	$lista_coisas['frutas'] = 'Maçã';
       	// O valor Maçã se sobrescreve ao valor Banana
        	*/

	// Jeito certo
	// Forma sequencial
        	//$lista_coisas['frutas'] = array('Banana', 'Maçã', 'Morango', 'Uva');

	// Forma associativa
	$lista_coisas['frutas'] = array(1 =>'Banana', 2 => 'Maçã', 3 =>'Morango', 4=>'Uva');
	$lista_coisas['pessoas'] = array(1 =>'João', 2 => 'José', 3 =>'Maria');

        	echo '<pre>';
        	print_r($lista_coisas);
        	echo '</pre>';

	echo <hr>;

        	// Apresentando no navegador
      	echo $lista_coisas['frutas'][3];
	echo '<br>';
	echo $lista_coisas['pessoas'][2];

?>

				AULA: ARRAY - MÉTODOS DE PESQUISA

Funções de pesquisa:

- in_array()

- array_search()

Em arrays multidimensionais, as funções funcionam da mesma forma, apenas temos que especificar corretamente os arrays no array multidimensional, como?

Temos que passar o nome dos arrays como sendo o índice do array multidimensional, assim os nossos métodos de pesquisas podem atuar tranquilamente nos arrays multidimensionais.

DIFERENÇA ENTRE OS DOIS

	in_array retorna true ou false para a existência do que está sendo procurado. No primeiro parâmetro passamos o elemento que queremos procurar, como segundo parâmetro 	passamos a onde estamos procurando. Para valores de true, o texto impresso será 1, caso contrário será vazio.
	
	array_search retorna o índice do elemento pesquisado, caso ele existe. No primeiro parâmetro passamos o elemento que queremos procurar, como segundo parâmetro 	passamos a onde estamos procurando. Caso o elemento não exista ele retorna null.

EXEMPLO

<?php
	// $lista_frutas = ['Banana', 'Maçã', 'Morango', 'Uva'];

	/*
	echo '<pre>';
	print_r($lista_frutas);
	echo '</pre>';
	*/

	/* 	in_array
	// Verificando a existência de alguma fruta
	echo in_array('Maçã', $lista_frutas);
	// true -> texto = 1
	// false -> texto = vazio

	 
	$existe = in_array('Abacate', $lista_frutas);

	if($existe) {
		echo 'Sim, o valor pesquisado existe no array';
	}else{
		echo 'Não o valor pesquisado não existe no array';
	}*/

	$existe =  array_search('Uva', $lista_frutas);

	if($existe != null) {
		echo 'Sim, o valor pesquisado existe no array';
	}else{
		echo 'Não o valor pesquisado não existe no array';
	}

	$lista_coisas = [
		'frutas' => ['Banana', 'Maçã', 'Morango', 'Uva'],
		'pessoas' => ['João', 'Maria']
	]

	echo '<pre>';
	print_r($lista_frutas);
	echo '</pre>';
?>


				AULA: EXTRA - FALSE NULL E EMPTY

Precisamos tratar esses valores pois como sabemos eles possuem grandes semelhanças e diferenças bem peculiares, por isso, eles são muito passíveis de bugs e erros

false (true/false) - tipo variável boolean

null e empty - valores especiais

FUNÇÕES

is_null - retorna true se o valor contido na variável for null, retorna false se o valor contido na variável for diferente de null.

empty - Verifica se a variável passada por parâmetro está ou não vazia, retorna true para valores vazios e false caso a variável tenha algum valor

VAMOS DE EXEMPLO:

<?php

$funcionario1 = null;
$funcionario2 = '';
$funcionario3 = false;

// valores null;
if(is_null($funcionario1)) {
	echo 'Sim, a variável é null';
}else{
	echo 'Não, a variável não é null';
}

echo '<br>';

if(is_null($funcionario1)) {
	echo 'Sim, a variável é null';
}else{
	echo 'Não, a variável não é null';
}

echo '<br>';

// valores vazios?;
if(is_null($funcionario1)) {
	echo 'Sim, a variável está vazia';
}else{
	echo 'Não, a variável não é null';
}

echo '<br>';

if(is_null($funcionario1)) {
	echo 'Sim, a variável é null';
}else{
	echo 'Não, a variável não é null';
}

?>

// Primeiro Nó
Podemos concluir que o valor null também é considerado vazio. Enquanto o vazio não necessariamente é considerado null. Enquanto que o false não é considerado como Null, mas é considerado como vazio

	- Null é exclusivamente Null

	- Empty pode ser considerado como vazio, Null e false

	- False pode ser considerado como vazio


					AULA: FUNÇÕES NATIVAS PARA MANIPULAR ARRAYS

Funções

is_array(array) -> Verifica se o parâmetro é um array

array_keys(array) -> Retorna todas as chaves de um array

sort(array) -> Ordena um array e reajusta seus índices. Caso consiga ordenar, retorna true, caso contrário, retorna false.

asort(array) -> Ordena um array preservando a relação índice-valor.

count(array) -> Conta a quantidade de elementos de um array

array_merge(array) -: Funde um ou mais arrays

explode(array) -> Divide uma string baseada em um delimitador. O retorno dessa divisão é dado num array

implode(array) -> Junta elementos de um array em uma string. É o contrário aqui, eu pego um conjunto de elementos num array e junto numa string.

					AULA: LOOPS PARTE 5: FOREACH

Esse comando foi especialzado para manipularmos array e objetos.

Como podemos mostrar as chaves e os valores dos elementos contidos num array utilizando o forach?

Simples, Exemplo:

$funcionarios = array('João', 'Maria', 'Júlia');

<?php
        echo '<pre>';
        print_r($funcionarios);
        echo '</pre>';

        foreach($funcionarios as $idx => $nome_funcionario){
            echo $idx . '<br>';
            echo $nome_funcionario . '<br>';
        }
?>

O segredo está na declarações de variáveis do foreach, repare que declaramos duas variáveis, o que aontece é que, o foreach entende automáticamente que primeira variável recebe as chaves dos elementos contidos no array $funcionarios, e a segunda variável vai receber os valores contidos nesses elementos, porém essas duas variáveis tem que ser separadas por um token, para que o interpretador entenda de forma clara que a primeira variável é para um objetivo e a segunda para outro, o token é o igual maior (=>)


					AULA: APP HELP DESK - ARQUIVOS INICIAIS

// Nessa aula dar início a nossa aplicação. Já no começo baixamos os arquivos iniciais, que estarão com as páginas prontas estilizadas com CSS e BootStrap, o que vamos fazer é aplicar a lógica PHP nessas páginas afim de chegarmos no nosso objetivo.

					AULA: APP HELP DESK - FORMULÁRIOS (DESVENDADNDO OS MÉTODOS GET E POST)

PARTES IMPORTANTES DO VÍDEO

- Como eu posso fazer com o que o meu formulário no FrontEnd, carregado no navegador se comunique com o nosso script "valida_login.php" do lado do servidor?

	Simples: Apenas coloque o atributo na tag form chamado (action="") e outro atributo no button chamado (type="submit"). O action é o destino do submit de um formulário, ou seja, pra onde aquele formulário será submetido. Quando nós clicamos em submit, o próprio browser encapsula as informações do formulário e dispara as informações através de uma requisição http para o servidor, com isso, do lado do servidor é possível recuperar esses parâmetros e efetuar ou não alguma tratativa em cima desses parâmetros e retornar uma resposta para o cliente, TUDO ISSO EFETUADO POR BAIXO DOS PANOS. Resumindo temos os lados  do Browser com a inteligência de recuparar esses dados e formar uma requisição http preenchendo o cabeçalho e o corpo dessa requisição e o Apache do outro lado, capaz de receber essa requisição, submeter para o script, receber o retorno do script, tal comunicação entre o Apache e a linguagem de programação é conhecida como CGI, então eles conversam, a linguagem retorna o arquivo para o Apache, e o Apache retorna essa informação para o cliente, tal informação pode ser uma página HTML, ou  também uma página com Assets,  ou seja, a página HTML, com o JavaScript, Imagens, arquivos de áudio, etc...

	Na declaração do destino do action, podemos passar apenas o arquivo do script cuja a pesquisa é feita no domínio do navegador, ou a URL completa, passando assim, o tipo de protocolo
		Ex: <form action="http://localhost/app_help_desk/valida_login.php">

	Para que o navegador possa pegar as informações do formulário precisamos colocar o seguinte atributo (name: "tipodeinformacao"):
		
		<input name"email" type="email" class="form-control" placeholder="E-mail">

		<input name="senha" type="password" class="form-control" placeholder="Senha">

	Isso significa que o name email passa a receber o valor contido no campo email, enquanto o name senha passa a receber o valor contido no name senha.
	Se não definirmos nenhum um método de envio por parâmetro, por padrão será reequisitado o método GET. Isso significa que as informações serão encaminhadas para o Servidor a partir da própria URL.

- Como pegar as informações no script.php?

	Simples: Podemos utilizar uma super global chamada $_GET[] (tudo em maiúsculo) que é um array, cada parâmetro encaminhado na URL se transforma em um índice nesse respectivo array.
		
		Ex: 
		$_GET['emai'];
		$_GET['senha'];

O que é importante ter em mente, a resposta dada pelo nosso servidor não é o script.php e sim o resultado da interpretação desse script, que é submetido para o Apache que controla essa função de requisição - resposta.

Vimos também que com o método GET, os dados são transferidos para a url, o que significa que expor os dados de um formulário na URL não é adequado porque estamos expondo as nossas informações, e outras pessoas podem acessar facilmente.

Mas podemos melhorar isso, modificando o método de envio do nosso formulário. Passando a utilizar o método POST

O método POST anexa as informações do formulário dentro da própria requisição, retirando esses dados por exemplo da url.

Para configurar o método POST, nos basta:

	<form action="valida_login.php" method="post">

No nosso script .php "valida_login.php" precisamos mudar a super global do método GET para POST.


					AULA: APP HELP DESK: AUTENTICANDO USUÁRIO

FUNÇÃO IMPORTANTE

- header('Location: index.php?login=erro');
	Efetua um desvio de páginas ao encontrar essa função.
	Podemos pssar um parâmetro de Login como erro, tal parâmetro pode ser ser recuperado pela página index, atraves da super global GET recuperar encaminhado na URL.

- isset()
	Verifica se um determinado índice de um determinado array está cetado, com isso, podemos verificar a existência desse índice antes de tentar utilizá-lo.


					AULA: APP HELP DESK - PROTEGENDO PÁGINAS RESTRITAS COM SESSION

Vamos aprender nessa aula a como proteger as nossas páginas utilizando o recurso de sessão do php.

Acontece que em algumas páginas da nossa aplicação (todas as outras fora a index.php), podem ser acessadas por uma requisição do php, vamos ver isso na prática.

Cada requisição feita por rotas individuais é na verdade um novo acesso. Ou seja, atraves da requisição-resposta faz com que ao requisitar uma nova requisição, o servidor http, receba essa requisição e trate de alguma forma. Porém front e backend não estão constantemente conectados, por isso muitas linguagens de programação do BackEnd utilizam um recurso chamado sessão que faz com que uma determinada instância do browser a partir de um identificador único tenha condições de acessar uma determinada sessão do lado do servidor que nada mais é do que um espaço de memória onde é possível do lado do servidor, armazenar algumas informações que conecte a instância da aplicação do lado do servidor com a instância da aplicação do lado do cliente, criando uma ponte, sendo que essa requisição é sempre transitada na requisição através de um cook ou através de uma URL. Resumindo a instância do Browser, sempre que quando realize uma requisição, encaminhe essa requisição para o servidor, para que a linguagem de programação tenha condições de recuperar essa informação e acessar aquele espaço de memória dedicado para aquela instância do Browser em especial. Criando esse recurso de sessão, nós podemos transitar informações em qualquer requisição feita pelo FrontEnd para o backEnd, podendo ser utilizada portanto, dentro de qualquer script.

- É importante iniciar o recurso de sessão sempre antes que qualquer instrução que emita para o navegador alguma saída.

	session_start();

	Definimos essa função, informando para o servidor que queremos acessar essa região de memória dentro desse script.

- Após iniciar a sessão temos disponibilidade para acessar uma super global chamada Session
	
	$_SESSION

	A super global na verdade é um array.
	
	É importante salientar que clientes diferentes possuem instâncias de Sessões diferentes, o que significa que uma aplicação de um site não comunica instâncias de diferentes requisições, ou seja, os clientes não tem acesso às variáveis de outros clientes.

	Todos os dados são salvos em formatos de cookies, que possuem um valor correspondente para cada instância do navegador criado. Esse cookie é transitado na requisição http, e do lado do servidor a partir desse cookie nós temos condições de acessar aquela sessão específica dedicada aquele browser. Cada sessão por default dura por três horas, isso significa que eu posso fechar o navegador, abrir o navegador novamente, ainda teremos a sessão estabelecida porque o cookie ainda estará presente dentro da nossa aplicação.

- Com isso podemos alguns recursos interessantes:

	Podemos criar variáveis de controle afim de verificarmos se um determinado script deve ou não ser retornado com base no valor de autenticação.


					AULA: APP HELP DESK INCORPORANDO SCRIPTS COM INCLUDE, INCLUDE ONCE, REQUIRE E REQUIRE_ONCE

com os recursos Include, Include_Once, Require e Require_Once nos permite encapsular os scripts de funcionalidades da nossa aplicação para utilizarmos em diversas outras funcionalidades, a fim de nós reutilizar códigos que sem eles, perderíamos tempo.

Tais construtores são bem semelhantes entre si

Um dos exemplos é o próprio site do Linkedin que na parte superior da página possui um menu que é igual para todas as páginas do Linkedin. Utilizando os recursos de inclusão de scripts do php, podemos criar uma situação muito semelhante a essa, em que toda a codificação do menu por exemplo é alocada em apenas um único script, e as páginas individuais, aos invés de implementarem cada uma toda a codificação do menu, simplesmente faz a inclusão desse script. Repare que nesse caso não temos uma redundância de código.

Como o próprio interpretador do php trata de formar os cabeçalhos de uma página web para encaminhar para o Apache, então, nós não teremos nenhum erro no processo de não precisar colocar tags html dentro da codificação php para que o resultado seja impresso.

DIFERENÇAS ENTRE CONSTRUTORES

INCLUDE E REQUIRE - A diferença entre o Include e o Require consiste na forma que o comando trata um potencial erro na inclusão que é realizada. Então quando um include produz um erro nesse processo de inclusão do script ele não acha o script que queremos adicionar, ele gera um warning, enquanto o require gera um fatal error. A diferença entre warning e fatal error, é que é apenas um alerta, o processamento do script dali em diante não é afetado. Já o fatal error interrompe completamente o funcionamento do script.

INCLUDE_ONCE E REQUIRE_ONCE - O que nós temos nessa situaçãoé o mesmo comportamento de erro, porém o Include_once e o Require_once permite a inclusão de um script apenas uma única vez, para entender isso melhor, vamos ver isso na prática...

					AULA: APP HELP DESK - REFACTORING DO PROJETO COM REQUIRE_ONCE

Nessa aula, o nosso objetivo é fazer um refactoring do app Help Desk com o objetivo de isolar a lógica de revalidação de acesso para reaproveitar essa lógica nas páginas que serão protegidas. Tais páginas: home.php, consultar_chamado.php, abrir_chamado.php implementam a mesma lógica de validar acesso. Mas agora nós sabemos como isolar e aproveitar essas lógicas quando forem necessário.

Nessa aula utilizamos o require_once para integrar a lógica e codificação de acesso nas páginas home.php, abrir_chamado.php e consultar_chamado.php, num novo arquivo, "validador_acesso.php", mas por que utilizamos require_once?

Simples, porque se ocorrer qualquer problema durante a recuperação do nosso script chamado de validador_acesso.php, eu quero que um fatal error seja acusado, para que assim, toda a minha aplicação app help desk seja ompedido/parado.

					AULA: APP HELP DESK - ENCERRANDO A SESSÃO (LOGOFF)

// Como sabemos agora criar essas variáveis de Sessão, nada mais justo do que aprender a como destruir essas variáveis de modo a por exemplo, implementar recursos como um logoff, a opção de sair intencionalmente da sessão iniciada com uma aplicação web.

O primeiro passo no nosso caso, é incluir um link no arquivo home.php com a descrição "Sair", que nos permita direcionar a nossa aplicação para um Script.php que tenha a inteligência de fazer a remoção das nossas variáveis de SESSÃO.

remover índices do array de sessão
      unset()

	Tal variável espera o array e o índice a ser removido. Tal variável não é exclusiva apenas a super global SESSION, ela serve para qualquer índices de qualquer array.
	Tal função tem a inteligência de destruir os índices apenas se estes existirem dentro do array().

destruir a variável de sessão
     session_destroy

	Tal função é exclusiva para variáveis do tipo Sessão. Essa função remove todos os índices na super global Session.
	Porém, mesmo destruindo a variável de sessão, ainda teremos acesso aos índices da mesma, pois estes já foram requisitados, tornando indiferente a utilização do logoff. Precisariamos criar uma nova sessão, para de fato enxergar a destruição das variáveis de sessão. Por isso que é muito comum, após executarmos a função session_destroy, em sequência forçar um redirecionamento de modo a forçar automáticamente uma nova requisição http para o nosso servidor, sendo que nessa nova requisição http, as variáveis de sessão não estarão mais disponíveis.
	Ou seja, para possamos ver os efeitos dessa função, precisamos fazer uma nova requisição.


					AULA: APP HELP DESK - REGISTRANDO CHAMADOS

Vamos trabalhar no registro de chamados da nossa aplicação por meio de um arquivo .txt

Precisamos que, através de uma de requisição http recurperar os dados do formulário e encaminhar para o servidor e podemos fazer esse envio utilizando os métodos de GET ou POST, e aí do lado do servidor nós vamos interceptar essas informação (seja por GET ou POST) e vamos na sequência abrir, escrever, e fechar um arquivo .txt, de modo que a informação encaminhada de um formulário, um FrontEnd da aplicação rodando num cliente possa ser armazenada de forma digital do lado do servidor, ou seja, nós vamos de fato persistir essas informações para que elas possam ser utilizadas depois.

No formulário, para encapsulamento e envio das informações é aconselhável a utilização do método POST, pois temos que tais informações são compostas por diversos caracteres, mas podemos fazer com GET

ATENÇÃO

	Parece que o type Submit não funciona com o a tag link "a", isso faz com que os dados não sejam encapsulados, consequentemente não consguimos ver o array com as informações desejadas.
	Utilize para esse fim, tag button, com o atributo href, desse modo, funcionará como o link.

Para podermos abrir, escrever e fecharmos o arquivo de texto que iremos criar, o próprio php possui algumas funções nativas para manipularmos o documento de texto.

ABRIR DOCUMENTO DE TEXTO:

	fopen('arquivo.txt', '');
		espera dois parâmetros, o primeiro caso é o nome do arquivo. Nesse caso poderíamos até definir uma extensão própria, pois o nosso arquivo é de texto puro e como nós sabemos qual que é o conteúdo e futuramente como interpretar esse conteúdo, sem problema algum definir uma extensão própria como ".hd" de Help Desk. Caso o arquivo não exista ele será criado.

		O segundo parâmetro indicamos o que queremos fazer com esse arquivo, se queremos abrir esse arquivo, se nós queremos apenas ler, se queremos posicionar o cursor no começo ou no término do arquivo. Procure no Manual do PHP os parâmetros possíveis para manipulação de arquivos utilizando a função fopen. Nessa aula escolhemos o parametro 'a' que abre e lê o arquivo.

O QUE TEMOS:

echo '<pre>';
print_r($_POST);
echo '</pre>';

fopen('arquivo.hd', 'a');

Na sequência, precisamos definir o que é que tem que ser escrito dentro do arquivo, tal conteúdo será obtido do textarea do abrir_chamado.php, no entanto, tais informações são obtidas por meio de um array, o $_POST, com isso temos que transformar para um conteúdo do tipo de texto.

echo '<pre>';
print_r($_POST);
echo '</pre>';

fopen('arquivo.hd', 'a');

$text = $_POST['titulo'] . $_POST['categoria'] . $_POST['descricao'];

echo $texto;

Desse modo, temos um texto com as nossas informações todas juntas, mas para que nós possamos tratar devidamente tais informações, o correto seria separar o titulo, categoria e descrição por um caractere especial incomum de termos textos, um deles é o jogo da velha (#), ficaria

echo '<pre>';
print_r($_POST);
echo '</pre>';

fopen('arquivo.hd', 'a');

$texto = $_POST['titulo'] .'#'. $_POST['categoria'] .'#'. $_POST['descricao'];

echo $texto;

No entanto, há a possibilidade de nós escrevermos o jogo da velha nas informações do formulário, isso iria quebrar a nossa separação de conteúdos, no entanto podemos utilizar uma função chamada de str_replace, que procura num conjunto de caracteres, um caractere desejado, e o troca por outro, tal função irá trocar o jogo da velha (#) por traço (-). Fica asim:

<?php

    echo '<pre>';
    print_r($_POST);
    echo '</pre>';

    //fopen('arquivo.hd', 'a');

    $titulo = str_replace('#','-',$_POST['titulo']);
    $categoria = str_replace('#','-',$_POST['categoria']);
    $descricao = str_replace('#','-',$_POST['descricao']);

    $texto = $titulo .'#'. $categoria .'#'. $descricao;
    echo $texto;
?>

Outra função mportante é a implode, que transforma um array em uma string. fica o desafio tirar o mesmo resultado utilizando tal função.

Já abrimos o arquivo, e criamos a variável de texto, agora precisamos escrever tal variável no arquivo que abrimos. Fazemos isso com a função fwrite();

	fwrite()
		Tal função espera dois parâmetros, o primeiro é a referência do arquivo que abrimos, precisamos armazenar essa referência numa variável. E como segundo parâmetro informamos o que é que queremos escrever dentro desse arquivo. Como nós estamos definindo na abertura do arquivo (fopen) o parâmetro 'a', então a função fwrite tem a inteligência de acrescentar o texto no final do arquivo. Por isso, escolher o parâmetro adequado para cada situação é importantíssimo, porque ela indica para a função de escrita ou para a função de leitura, como é que aquela funçã deve trabalhar. Por fim, depois de escrevermos nesse arquivo, precisamos fechar tal arquivo.

Até agora escrevemos no nosso documento arquivo.hd as informações, no entanto, apenas de termos as separações do jogo da velha, separando o que é titulo de descrição, e categoria, precisamos separar também os pedidos de ajuda que se encontram em apenas uma linha, mas como fazemos? podemos separar por esse símbolo '|', no entanto, se o usuário digitar esse símbolo nas informaçoes do formulário, iria quebrar a nossa separação, com isso teríamos que novamente gerar a função str_replace para trocar o símbolo por outro, porém, temos uma constateespecífica do php chamada PHP_EOL

PHP EOL
	PHP_EOL é uma constante que armazena o caractere de quebra de linha de acordo com o sistema operacional que o sistema está rodando. Isso é legal porque não existe a necessidade de testar qual é o sisstema operacional para decidir como que vamos quebrar a linha dentro dos nossos arquivos de texto.


						AULA: APP HELP DESK: CONSULTANDO CHAMADOS

Nossa aula se concentra maiormente no arquivvo consultar_chamado.php:

FUNÇÕES

fgets - retorna o registro dentro do arquivo
feof - Lê o o registro do arquivo e retorna true quando chegar no seu final, e false, indicando que não chegou.

CÓDIGO DE AULA:

<?php

  // abrir o arquivo.hd
  $arquivo = fopen('arquivo.hd', 'r');

  // enquanto houver registros (linhas) a serem recuperados
  while(!feof($arquivo)){ // testa pelo fim de um arquivo
    //linhas
    fgets($arquivo);
  }

  //...
?>

Primeiramente abrimos o arquivo de texto, com o parâmetro 'r' para ler esse arquivo. Depois colocamos uma estrutura de repetição que irá percorrer todos os caracteres desse texto utilizando como condição uma função feof($arquivo) que percorre todo o array de caracteres desse arquivo e retorna true, quando ela chegar ao seu fim (por isso o operdor de negação, que retorna true, caso enquanto não chega no final do arquivo) . Para cada repetição, iremos recuperar o registro dentro do arquivo utilizando a função fgets($arquivo)


Tenha em mente que o php está gerenciando toda a abertura de arquivo para nós, então nós temos a referência de arquivo aberto, e quando nós executamos a função feof($arquivo) nós estamos posicionando o cursor do php na primeira linha desse arquivo, para verificar se é ou não o final do arquivo, como não é o caso, nós vamos retornar false, a inversão do retorno nos vai dar true, e iniciar o laço de iteração, o fgets tem a inteligência de com base no arquivo aberto e na posição do cursor recuperar o que estiver ali, naquela linha até uma quantidade determinada de bits - que pode ser informada como segundo parãmetro na função fgets - ou até encontrar o final da linha / quebra de linha. E aí quando a função feof fizer mais um teste, o ponteiro do mouse será posicionado no começo da seguna linha, como não é o fim do arquivo, ele irá continuará a iterar por meio do while.

É importante compreender que por trás o php está gerenciando esse arquivo que está aberto na lógica da aplicação, por isso, é importante ter o cuidado de ao término da manipulação de um determinado arquivo, fechá-lo.

<?php

  // abrir o arquivo.hd
  $arquivo = fopen('arquivo.hd', 'r');

  // enquanto houver registros (linhas) a serem recuperados
  while(!feof($arquivo)){ // testa pelo fim de um arquivo
    //linhas
    $registro = fgets($arquivo);
    echo $registro.'<br/>';
  }

    // fechar o arquivo aberto.
    fclose($arquivo);
?>

Feito isso, podemos declarar para cada uma das linhas, um array, no qual eu irei manipular paradar acesso para o usuário diretamente do FrontEnd.

AGORA VAMOS COLOCAR TAIS INFORMAÇÕES NO CARD

	para isso criamos uma estrutura de repetição na qual irá iterar a quantidade de cards necessários para que todos os chamados sejam atendidos.

	Para retirarmos de cada string as informações corretas separadas por delimitadores, que no caso é o '#', utilizamos o explode, que retorna um array com as informações separadas. Colocamos cada índice do array no card e voa lá kkkk. Só para finalizar, um card ainda está sobrando por causa da constante específica de do php (PHP_EOL) que cria quebra a linha do arquivo.hd e cria uma nova, para resolvermos isso, verificamos se o array que criamos possui as informações necessárias do card, se não saimos da iteração do loop com "continue".


						AULA: APP HELP DESK - APLICANDO CONTROLE DE PERFIL DE USUÁRIOS

Nessa aula nós temos um desafio bem interessante pela frente, nós vamos aplicar uma regra de controle de perfis de usuário. Imagine que a nossa aplicação cresceu, e ela possui mais usuários, e nós precisamos nesse momento controlear a visibilidade de chamados abertos na aplicação. Nós vamos portanto criar dois perfis o perfil admnistrativo e o perfil usuário, o perfil administrativo implementa a seguinte regra, qualquer usuário do perfil administrativo pode visualizar os chamados de qualquer usuário, ou seja, quem é administrativo visualiza tudo. Já o perfil usuário implementa a seguinte regra, quem é do peril usuário pode visualizar apenas os seus  próprios chamados.

A nossa regra está associada com os chamados, e uma informação importante, é verificar quem foi que fez o chamado, ou seja, de alguma forma, o chamado precisa ter uma conexão com o usuário. Nós precisamos guardar o identificador no chamado que indique quem foi o usuário responsável por sua respectiva abertura. Nesse caso, poderíamos utilizar o próprio email do usuário, para fazer essa associação com o chamado. Mas para deixarmos as coisas um pouco mais complexas, utilizaremos o ID, de tal modo que se no futuro o email do usuário sofrer alguma alteração, não tem problema, porque a associação com o registro está pelo o ID e não pelo o EMAIL.

MÃO NA MASSA!

$usuarios_app = array(
        array('id' => 1, 'email' => 'Lucas@gmail.com', 'senha' => 'LuguJo90'),
        array('id' => 2,'email' => 'guga1234@gmail.com', 'senha' => '123456'),
        array('id' => 3,'email' => 'josylima455@gmail.com', 'senha' => '123456'),
        array('id' => 4,'email' => 'ivan89891@gmail.com', 'senha' => '123456'),
    );

adicionamos mais um elemento, para cada um dos arrays. O próximo passo, é fazer com que o ID do usuário autenticado esteja disponível em toda a instância da aplicação. Ou seja, após fazer a autenticação, é fundamental que a informação de ID esteja disponível para ser utilizado em qualquer ponto da lógica da nossa aplicação. A variável de sessão será responsável por deixar o nosso índice acessível em toda a lógica da aplicação.

foreach($usuarios_app as $user){

        if($user['email'] == $_POST['email'] && $user['senha'] == $_POST['senha']){
            $usuario_autenticado = true;
            print_r($user);
        }
}


					AULA: APP HELP DESK - SEGURANÇA NO BACK-END DE APLICAÇÕES WEB

Cada vez mais daqui pra frente é importante que você atente às dicas de segurança para evitar que o Back-end da sua aplicação web fique exposto.

VULNERABILIDADES DO APP HELP DESK:

- Todos os nossos arquivos que criamos na pasta App Help Desk está disponível para o mundo, o que significa que muitas das funcionalidades importantes do nosso app, está exposto

- Mesmo que tenhamos as páginas consultar_chamado.php, abrir_chamado.php, home.php sendo verificadas, e protegidas pela variável de Sessão. Um usuário mais experiente poderia, ao invés de acessar o arquivo pelo navegador, poderia baixar essas páginas, dando ele acesso a todos os nossos scripts, deixando assim, a nossa aplicação facilmente manipulável.

// A partir de agora, só irá ficar no diretório público do servidor http, arquivos ou scripts que não são sigilosos.

Para que possamos contornar essa vulnerabilidade, nós vamos resolver dois problemas da nossa aplicação que é justamente: O arquivo.hd e o valida_login.php, retirando esses arquivvos e scripts do diretório público do serviddor http. Dessa forma, nenhuma requisição feita para o servidor conseguirá recuperar esses arquivos porque eles não existem do repositório público, será necessário uma inteligência por trás para que esses arquivos sejam recuperados, não mais por requisições http feitas por dispositivos na internet, apenas feita pela aplicação.

c:/xampp
	- app_help_desk (será diretório de arquivos e scripts sigilosos)
	- htddocs / app_help_desk (diretório público)


					SECTION 12 - PHP7 E ORIENTAÇÃO A OBJETOS
					AULA: OO - PILAR DA ABSTRAÇÃO

Abstração nada mais é do que a forma de como interpretamos as coisas do mundo real, e transformamos essas coisas para dentro das nossas aplicações, para compreender bem o que é esse princípio de abstração nós precisamos entender também o que é entidade, identidade, características e ações.

ENTIDADE - A entidade é na verdade a compreensão de que um objeto do mundo real deve passar para dentro da aplicação, para entender isso melhor, imagine por exemplo que você possui um e-commerce e você vende produtos, logo um produto que é um objeto do mundo real, precisa ser reproduzido dentro da nossa aplicação, então nós precisamos abstrair esse produto para definição de um modelo desse respectivo objeto ser reutilizado dentro da nossa aplicação.

IDENTIDADE - Nós podemos ter dentro da nossa aplicação, um modelo de um produto, porém, esse modelo pode ser base de vários produtos diferentes, logo, é necessário haver uma identidade para cada um dos objetos criados com base nesse modelo para que possamos acessar esses respectivos produtos futuramente dentro das nssas aplicações. Ou seja, é no processo de criação, ou instância dos objetos com base nos modelos que foram definidos através de um processo de abstração da entidade que nós podemos portanto, criar essa associação de identidade, ou seja, estabelecer uma referência que irá futuramente nos permitir acessar  objeto em questão.

CARACTERÍSTICAS - São atributos desses modelos

AÇÕES - São métodos, ou comportamentos.

Entidade		Identidade		Características			Ações

Produto		x = new Produto()		categoria, título, descrição, valor	exibirResumoProduto, alterarValorProduto
Ideia		z = new Ideia()		tipo, descrição, complexidade		modificarTipoIdeia
Funcionario	y = new Funcionario()	nome, telefone, numFilhos		resumirCadFunc, modificarNumFilhos


					AULA: OO - GETTERS E SETTERS

Os métodos Getters e Setters são métodos que permitem atender uma convensão que diz qual que é a melhor forma de acessar e modificar os valores dos atributos.

A comunidade de programadores acabou adotando essa convenção por acreditarem ser uma boa prática.
 

					AULA: OO - MÉTODO CONSTRUTOR E DESTRUTOR (CONSTRUCT E DESTRUCT)

EXEMPLOS:

__construct()
__destruct()

// underline underline ( __ ) configura a chamada de um método mágico.
// É fundamental que os nomes do construtor e destrutor sejam esses, para que sejam iniciados em seus deviddos tempos.

Os métodos construct e destruct fazem parte do que vamos considerar ser o ciclo de vida de um objeto, então quando nós criamos a instância de um objeto com base numa classe, automáticamente, o método construct é executado de modo que uma ação possa ser tomada no processo de inicialização do objeto, sendo essa ação disparada automaticamente em função da instância. Já o método destruct é executado automaticamente, quando a instância do objeto é removida da memória, ou seja, quando aquele objeto dentro da nossa aplicação deixa de existir, para entender isso melhor vamos ver o seu funcionamento na prática.

Quando removemos um objeto de forma proposital, o método destruct é disparado neste exato momento, no entanto, é possível que ele possa ser executado de forma não proposital, com o objeto sendo removido pelo simples fato da finalização da interpretação do script, ou seja, após a interpretação do script, e consequente formação da resposta que vai ser dada para quem fez a requisição desse script, é natural que o php desaloque os valores de memória do lado do backend, fazendo com que nesse exato momento, o método destruct do objeto seja executado.


					AULA: OO - PILAR DA HERANÇA

Esse pilar da herança nos traz uma vantagem que é a redundância de código, o que significa que nos permite refatorar o código de maneira mais simples, digamos assim


					AULA: OO - POLIMORFISMO

Polimorfismo é a sobrescrita de métodos, temos o objeto pai e os objetos filhos, sendo que os objetos filhos herda os métodos e atributos dos objeto pai, mas não necessariamente o objeto filho tem que se comportar da mesma forma que o objeto pai, nessas situações, nós corrigimos os comportamentos do filho, através da sobrescrita de métodos ou polimorfismo.

					AULA: OO - PILAR DO ENCAPSULAMENTO - PARTE 1

O Encapsulamento possui dois lados, o lado conceitual e o lado técnico, nessa aula nós vamos aprender os dois.

LADO CONCEITUAL

O encapsulamento consiste em encapsular o objeto de tal modo a tornar esse objeto seguro, o que significa que esse objeto terá condições de dizer o que dentro dele está disponível no sistema, se você se lembra bem, os objetos são constituídos de métodos e atributos, o encapsuamento portanto, é uma forma de controlar a visibilidade desses atributos e métodos de acordo com as necessidades de negócio, na prática, podemos definir se tal atributo/método é privado ou público ou até mesmo se esse atributo ou método deve ou não ser herdado pelos seus filhos criando com isso, uma camada de segurança para cada um dos objetos da nossa aplicação.

Quando falamos em encapsulamento é muito importante ter em mente os operadores de visibilidade, sendo eles o public, protected, e o private. Tais operadores são responsáveis por definir que os controles de visibilidades sejam atendidos nos atributos e métodos.


PARTE MAIS IMPORTANTE

1 - Uma parte das mais importante dessa aula foi nós vermos os métodos mágicos getters e setters modificarem a acessibilidade dos atributos que inicialmente estão como private e protected, sua modificação é interessante porque, não acessamos e modificamos os seus valores (dos atributos) referenciando os métodos getters e setters, não, fazemos isso apenas referenciando o método e retornando o seu valor, como se trocássemos o private e protected para public.

2 - Porque tornar um método pro=ivado se eu não posso referenciar ele fora da classe que ele foi instanciado? Devemos ter em mente que tais métodos devem se tornar privado, para tornar seguro a nossa aplicação, no entanto, eu irei referenciar tais métodos privados indiretamente a partir de uma regra de negócio que estará contido num outro método que é público, parece que estou andando em voltas, mas na verdade, torna a minha codificação ser aberta apenas por uma porta e com uma chave, onde tal porta conterá todas as outras entradas.

					AULA> OO - PILAR DO ENCAPSULAMENTO PARTE 2

Nessa aula vamos ver como que o encapsulamento se comporta quando falamos de herança entre a classe Pai e a classe Filho.

Modificadores de visibilidade como public e protected podem passar os métodos e atributos da classe Pai para a classe Filho, no entanto, o filho não herdará aqueles atributos/métodos cujo o modificador de acesso está cetado para private.

Quando não existe atributos numa determinada classe, podemos criá-los a partir dos métodos setAtributo, no qual foi modificado a partir de uma um objeto instanciado dessa classe. Ou seja, caso não exista os atributos passados por parâmetros para essa função, será criado tal atributo dinamicamente.

FUNÇÕES:

get_class_methods($filho) - Retorna os métodos de um determinado objeto em um array.

- Os métodos mágios getters e setters possuem uma diferença peculiar em relação aos outros métodos, pelo fato de o php ter uma inteligência por trás desses recursos. Como por exemplo, ajustar o contexto de recuperação de um determinado atributo. Vemos no caso anterior que atributos com modificadores de visibilidade private, não são herdados das classes filhos a partir das classes pais, o que significa que não podem ser instanciados certo? Em partes, porque essa regra não funciona quando falamos dos métodos mágicos getters e setters, eles conseguem instanciar atributos declarados como private mesmo que tal atributo não faça parte do contexto do filho, pois ele não foi herdado. O que significa que o nome (Jorge) consegue ser instanciado e modificado a partir das classes filhos por meio dos getters e setters mágicos, desde que, tais métodos mágicos sejam declarados no escopo do pai, e assim, herdados pelos filhos. Caso os métodos getters e setters mágicos sejam declarados apenas nos filhos, tais métodos só irão trabalhar no contexto do objeto filho, o que significa que os casos anteriores não poderão ser vistos nesta situação.

PUBLIC E PROTECTED

Métodos e atributos marcados como Public e Protected na classe Pai são herdados pelos Filhos.

PRIVATE

São visíveis para o objeto, mas não são herdados pelos filhos. Mas podem ser instanciados pelos métodos Getters e Setters mágicos que estiverem na classe Pai.

Mas vamos ver uma exceção, na classe Pai, existe um método responder() declarado como protected, e ele não foi visualizado (através do print_r) pelo filho, por quê?

Simples, porque num processo de herança, os operadores de visibilidade também são herdados, por ser um método protected, a aplicação, que é responsável pela consulta desses métodos no objeto não tem acesso a listar essa informação para nós, justamente por ser um método protegido do objeto, então o que é podemos fazer nesse caso? Simples, solicitar que o próprio objeto exponha os seus métodos para a aplicação, podemos fazer isso por meio da método construtor, que será automáticamente instanciado, e dentro dele, referenciar os métodos (print_r(get_class_methods($this)). $this pegará sem exceção todos os métodos da classe pai.

PRIVATE

Ele pode ser referenciado por um método público, quando o filho herda o método público, e não o private, mesmo não herdando o private, podemos acessar o método private pelo público com o operador $this, nesse contexto, o método private que estiver sendo instancia pelo $this vai ser executado na mesma hora, mas tal método é do pai, se o filho tiver um método private com o mesmo nome do método private do pai e for instanciado pelo método públic do pai, será executado o metodo private do pai

PROTECTED

Se o método protected do pai for herdado pelo filho, e esse for instanciado pelo método públic do pai que agora passa a ser do filho, chamando o método protected, será executado na mesma hora, no entanto, se o filho tiver um método com o mesmo nome do método protected do pai e referenciarmos ele através do método públic do pai, será executado o método proteceted do filho.

						AULA: ATRIBUTOS E MÉTODOS ESTÁTICOS

Atributos e métodos estáticos podem ser acessados sem que seja realizado a instância do objeto de uma determinada classe.

ACESSANDO OS MÉTODOS/ATRIBUTOS DIRETO DA CLASSE:

Exemplo::metodo1;

// Operador de Resolução de Escopo(::)

- cessível através do operador ->

- Não pode utilizar o $this

$THIS

	Ajusta o contexto das variáveis internas dos métodos para trabalhar com os atributos dos objetos

CASO ESPECIAL

	Se não instanciarmos um  objeto, e apartir da classe, fizermos uma chamada de um método estático, e denro desse esmo método referenciar ou instanciarmos - pelo parâmetro $this -  um atributo/método que não está estático, resultará em erro, pois os atributos e métodos não estáticos, só podem ser acessíveis depois de declararmos um objeto dessa classe, é como se ele não existisse.


						AULA: INTERFACES

As classes definem os modelos para os nossos objetos, já as interfaces definem os métodos cujas classes precisam obrigatoriamente implementar, elas funcionam como uma espécie de contrato, fazendo com que as classes que implementem esses respectivos interfaces respeitem os métodos estabelecidos nesses contratos, de modo a fazer com que a nossa aplicação tenha uma certa homogeneidade

Vamos criar nessa aula, duas classes para a instância de dois objetos diferentes que são a Geladeira e a TV.

As Interfaces como comentamos, funcionam como uma espécie de contrato, elas definem os métodos que devem ser obrigatoriamente construídos dentro das classes que implementam aquela respectiva interface, reparem que são apenas os métodos, atributos não entram nesse contrato, Como criamos? e Como fazemos sua implementação na classe desejada?

Veja no seu código fonte interface.php que criamos na aula....

SOBRE INTERFACES

- Interfaces não implementam os métodos, apenas definem a sua assinatura, quem fará a implementação do método será a classe que implementou a interface.

- A implementação da interface na classe é feito em tempo de execução do interpretador.

- Em times de desenvolvedores muito grandes , é natural que a definição das classes, ou melhor, dos métodos das classes acabem sendo ligeiramente dferentes, e as interfaces podem definir métodos comuns para as nossas classes de modo a criar essa homogeneidade, então você passa para o seu time que para desenvolver uma determinada classe você precisa implementar a interface x,  e com isso, você ganha em dois pontos, primeioro, o programador vai obrigatoriamente ter que implementar aquele método, não existe perigo dele de repente negligenciar aquele método por qualquer motivo, e ele vai criar aquele método com a assinatura que você estipulou, de modo que você possa criar uma certa homogeneidade como um todo.

- Podemos implementar mais de uma interface para uma determinada classe, de modo a sofisticar mais ainda a nossa codificação.

- Interfaces devem ser iniciadas com caracteres maiúsculos.

- Não é obrigatório utilizar o interface na definição das interfaces:

	interface MamiferoInterface{}

	interface MamiferoInterface{}

- É possível que Interfaces herdem regras contidas dentro de outras interfaces

						AULA: NAMESPACES PARTE 1 - UTILIZANDO NAMESPACES PARA CLASSES E INTERFACES


NAMESPACES

	Namespaces foi criado tendo em mente o conflito que é gerado quando utilizamos bibliotecas externas ao código para aumentar a produtividade da nossa aplicação, pois variáveis, contantes, funções, interfaces, entre outros, podem ter os mesmos nomes que os quais estamos desenvolvendo, pensando nisso, a comunidade de programadores pensaram em como resolver tal problema.

SOBRE NAMESPACES

- Precisam ser declarados antes das nossas classes, sua limitação se define quando declaramos outro namespace.

- Quando queremos utilizar bibliotecas, precisamos incluir namespaces na nossa aplicação a partir de outros script (arquivos digitais).

- Para criarmos um objeto de uma classe contida num namespace, onde tal instância de objeto é fora do respectivo namespace, precisamos referenciar qual que é o namespace em questão...  Barra invertida, nome do namespace, barra invertida e o nome da classe.

	$c = new \A\Cliente();

- O mesmo funciona quando temos uma classe e queremos implementar interface de outro namespace, para isso basta:

	class Cliente implements \B\CadastroInterface {}


						AULA: NAMESPACES PARTE 1 - IMPORTANDO E APELIDANDO NAMESPACES

A proposta dessa aula é levar os conceitos de namespaces para um patamar mais próximo do mundo real, para entender de fato quais são os benefícios na utilização de namespaces, acontece que existem muitas necessidades que são comuns no dia a dia do desenvolvedor que já foram de algum modo tratado por outros programadores ou até mesmo por outras empresas. E é muito comum que esses programadores com essas empresas disponibilizem pequenas bibliotecas para objetivos bem específicos permitindo por exemplo com que essas bibliotecas sejam baixadas e habilitadas dentro do nosso código. Ocorre que ao implementar códigos prontos nós podemos ter conflitos em relação aos nomes de classes interfaces funções ou constantes. é por isso que nós utilizamos o recurso de namespaces para evitar que essas bibliotecas entrem em conflito com os nossos códigos ou até mesmo com outras bibliotecas.

INCLUINDO BIBLIOTECAS

	Podemos utilizar o include, include_once, require, e require_once.

	A importação só é válida para classes e interfaces, a importação para funções e constantes não se aplica.

	Para utilizarmos as classes e interfaces utilizamos a expressão e indicamos o namespace:

		use B\Cliente;

ALIASING (APELIDO)

	Imagine que precisamos trabalhar com as duas bibliotecas, logo precisamos de uma instância, ou seja, de um objeto de cada uma das classes, tanto da lib1 quanto da lib2, como é que nós podemos trabalhar isso? Simples, kkk Veja o exemplo, palavra reservada "as":

		use A\Cliente as C1

						AULA: TRATAMENTO DE ERROS: EXCEÇÕES CUSTOMIZADAS

Em algumas bibliotecas que implementamos dentro do nosso código, é comum, lançar Exceções customizadas, essas exceções podem ser criadas com base na extensão da classe Exception.

Exception é uma classe nativa do php.

QUAIS EU DEVO UTILIZAR?

Error
	A class Error é base para lançamento de erros internos do php, então funções nativas do php que tratam erros e podem eventualmente lançar erros na sua execução, implementam objetos de erro baseado na class Error, então essa classe geralmente não utilizamos no dia a dia.

Exception
	Nós como programadores iremos geralmente lançar exceções para serem capturadas no Catch
Customizadas
	Mas nada impede que classes customizadas sejam usadas por nós programadores para ançamento de erros mais personalizados. Além disso é muito comum que bibliotecas prontas implementem classes de erros customizadas , se for esse o caso fique atento no Catch, mais expecificamente na tipagem do objeto recebido para ver se a tipagem está sendo feita de acordo com a classe customizada.

						AULA: APP SEND MAIL - CONFIGURANDO O PHPMAILER E ENVIANDO E-MAILS

SERVIDOR SMTP

É um servidor que tem um funcionamento muito parecido com os correios, nós despachamos uma determinada correspondência e ele é responsável por receber essa correspodência e organizar a sua entrega. Atualmente, nós temos a disposição, diversos servidores SMTP disponível na internet de forma gratuita como por exemplo, o próprio Gmail do Google, que é uma excelente opção que inclusive será configurado nessa aula para que nós possamos fazer esse processo de envio.

O nosso FrontEnd se comunica com o nosso BackEnd, através do protocolo http, enquanto a nossa aplicação implementa uma biblioteca que vai utilizar um serviço disponível na internet. Então através da internet, utilizando o protocolo SMTP, nós vamos fazer uma autenticação no Gmail para a partir da nossa aplicação disparar um e-mail, sendo o G-mail, o responsável por fazer essa entrega ao destinatário

INFELIZMENTE IREI PARAR DE DESENVOLVER ESSA APLICAÇÃO POR APRESENTAR DIVERSOS ERROS NÃO CORRIGIDOS

						AULA: UM POUCO MAIS SOBRE SQL

A linguagem SQL divide um subcategorias da sua linguagem que são:

DDL - Data Defition Language - Linguagem de definição de dados

	Relacionado à criação, alteração e remoção das ESTRUTURAS de dados, repare que não se trata dos dados propriamente dito, mas sim das estruturas que reberão esses dados posteriormente.

DML - Data Manipulation Language - Linguagem de manipulção de dados

	Nos permite a inclusão, alteração e remoção dos REGISTROS dentro das estruturas de dados.

DCL - Data Control Language - Linguagem de controle de dados

	Nos possibilita gerenciar o acesso por parte de usuários externos ao SGBD (Sistema Gerenciador de Banco de Dados)

DTL - Data Transaction Language - Linguagem de Transação de dados

	Nos permite efetivar ou cancelar as transações junto ao SGBD.

	// Cada instrução executada em um banco de dados através de um SGBD é iniciada e finalizada através de uma transação, essa transação pode ser manipulada, justamente pelo conjunto de instruções DTL da linguagem SQL.

DQL - Data Query Language - Linguagem de consulta de dados

	Nos permite recuperar dados através do estabelecimento de cláusulas, de operações lógicas, de operações relacionais ou de funções de agregação

						AULA: CRIANDO E EXCLUINDO BANCOS DE DADOS

Bancos de dados são coleções organizadas de dados que se relacionam de algum modo, a idéia de um banco de dados consiste em agrupar registros de um domínio específico, isso não significa que existe um jeito certo e único de se criar um banco de dados, na verdade tudo vai depender do seu nível de abstração do assunto que virá naturalmente com o tempo e com a prática.

Quando estamos desenvolvendo uma aplicação geralmente criamos um banco de dados específicos para a aplicação, mas isso não significa que essa mesma aplicação não possa ter acesso ou controle sobre diversos outros bancos de dados ao mesmo tempo. Logo, é necessário tomar alguns cuidados em teoria do assunto. 

Um SGBD é um sistema gerenciador de banco de dados, por exemplo, o MySQL é um SGBD e através do MySQL podemos criar, manipular, excluir, enfim...Podemos controlar diversos banco de dados simultâneamente.

É possível que duas aplicações diferentes compartilhem um banco de dados em comum, e ao mesmo tempo, faça conexão com seus respectivos bancos de dados.

Podemos controlar diversos bancos de ddos através de comandos SQL, ou através de interfaces de bancos de dados que nada mais é do que um visual de comandos executados por trás.

É importante que conheçamos a linguagem SQL que é disposta para os mais diversos bancos de dados relacionais.

CRIAR BANCOS DE DADOS

// Pra fazer isso, precisamos usar um comando da subcategoria DDL (Data Definition Language)
// Ao criar um banco de dados, estamos modelando uma estrutura para armazenamento dos dados, nós não estamos falando ainda do "dado" propriamente dito.

	CREATE DATABASE "NOME_BANCO_DADOS";

REMOVER BANCOS DE DADOS

	DROP DATABASE "NOME_BANCO_DADOS";

// Importante para não remover os bancos de dados inerentes no phpMyAdmin pois foram criados para armazenar informações provenientes ao próprio MySQL.

----------------

As intruções SQL são sempre instruções imperativas, instruções que queremos o SGBD faça, mas nós temos a possibilidade de utilizar a interface visual para dizer o que o SGBD deve fazer.


						AULA: TABELAS E TIPOS DE DADOS PARTE 1 - UM POUCO DE TEORIA

O que são tabelas?

	Uma tabela é muito semelhante à uma planilha e pode ser entendida como uma unidade de armazenamento, isso porque tabelas são constituidas em um número finito de colunas e possuem um número indefinido de linhas, isso por que não sabemos a quantidade de linhas, ou melhor, de registros que serão armazenados dentro das tabelas.

Basicamente falando, as informações cadastradas em aplicações web, ou aplicações de modo geral através de formulários por exemplo, são processadas por uma linguagem de programação como php por exemplo, e posteriormente, os dados processados pela linguagem de programação podem opcionalmente serem inseridos como novos registros dentro de tabelas em bancos de dados.

Cada coluna de uma tabela é responsável por armazenar um tipo de dado específico, e isso deve ser definido no momento de criação da tabela.

Quando estamos falando em armaznamento de mídias, como imagens ou áudios, o que armazenamos não é a mídia propriamente dita, mas sim o nome do arquivo digital e a sua respectiva extensão para que a própria aplicação possa se encarregar de localizar esse recurso e posteriormente entregar esse recurso de forma apropriada o usuário final.

Podemos armazenar arquivos valores booleanos como por exemplo verificando a inatividade de um determinado curso. Essa forma é muito comum, pois dessa forma podemos manter registros de cadastros inativos dentro dos bancos de dados e isso é muito interessante para fins de controle e também de log.

Identificar os tipos de dados e aderir os dados corretamente na nossa tabela formatando as colunas, impacta diretamente no tempo da resposta que a base de dados terá com o usuário final.

Campos de texto:

	Text (tamanho variábel que armazena uma grande quantidade de catacteres)

	Varchar (tamanho variávek que armazena de 0 até 255 caracteres)

	Char (tamanho fico que armazena de 0 até 255 caracteres)

Campos numéricos:

	Int (valores numéricos inter=iros)

	Float (valores numéricos fracionados )

Campos de data e hora:

	Date (data no formato YYYY/mm/DD)

	Time (hora)

	Datetime (combinação de date e time em um mesmo campo)

Observe que na verdde, as tabelas são muito mais do que uma coleção de registros, são na verdade repositórios que qualificam os atributos de cada registro armazenado, isso significa que além dos dados de cada registro propriamente dito, teremos também associado a esses dados , metadados que podem e que serçao na verdade para por exemplo controlar a integridade da formação ou mesmo para otimizar pesquisas, além disso, indicar o tipo de campo corretamente vai nos permitir a trabalhar com funções nativas do SGBD que consequentemente irá otimizar todo o nosso trabalho no dia a dia.

						AULA: AULA: TABELAS E TIPOS DE DADOS PARTE 1 - UM POUCO DE PRÁTICA

Nessa aula iremos criar uma tabel que receba registros de cursos, no qual vamos definir uma estrutura de dados, então os comandos utilizados será da subcategoria DDL (Data Defition Language)

Vamos criar tabelas através da interface visual do phpMyAdmin.

CRIANDO TABELAS:

CREATE TABLE "nome_tabela" (
	"nome_coluna" int not null
);

// Os parênteses delimitam as colunas que será criado nessa respectiva tabela.
// not null significa "nenhum", é um valor pre-definido que precisa ser preenchido obrigatoriamente.
// Passar o parãmetro null indica que no processo de inserção de um registro, pode-se omitir a definição do valor dessa coluna, podendo portanto ser um atributo do registro "null".

CREATE TABLE tb_cursos (
	id_curso int not null,
	imagem_curso varchar(100) not null,
	nome_curso char(50) not null,
	resumo text null,
	data_cadastro datetime not null,
	ativo boolean default true,
	investimento float(8,2) default 0
);

// Através da palavra reservada default, nós podemos atribuir uma informação que será associada como valor dessa coluna no momento da inserção do registro como sendo a informação padrão caso ela não seja preenchida.

// O tipo float espera saber duas coisas. Primeiro, a quantidade de digitos envolvidos num determinado número por exemplo 5, e na sequência a quantidade de digitos correspondentes à fração desse respectivo número, por exemplo 2. Desse modo teremos como inserção de registros, números de 5 digitos, sendo que 2 desses digitos corresponderia à fração, por exemplo 753.44

DELETANDO TABELAS:

DROP TABLE tb_cursos (
	id_curso int not null,
	imagem_curso varchar(100) not null,
	nome_curso char(50) not null,
	resumo text null,
	data_cadastro datetime not null,
	ativo boolean default true,
	investimento float(8,2) default 0
);

Na criação de tabelas, definimos a coluna ativo, como sendo do tipo boolean, porém ao criar esse tipo de dado, temos que o nome passou a ser tinyInt(1), o que isso significa?

O boolean na verdade é um Alias para o tipo TinyInt no MySQL, TinyInt por sua vez é um tipo de dado que aceita valores numéricos que estejam dentro do range de um bit. A sacad aqui é o seguinte, se o valor do regitro, correspondente à coluna ativo for 0, significa que o valor é tratado como sendo false, caso contrário o valor contido no registro seja qualquer coisa diferente de 0, o valor é tratado como sendo true.

0 = false
qualquer outro valor = true

						AULA: EXTRA - ENTENDENDO A DIFERENÇA ENTRE CHAR E VARCHAR

DIFERENÇA:

CHAR - 10 posições 

	Tamanho fixo em disco

	Vantagem: Mais rápido para pesquisas

	Desvantagem: Quando mau utilizado pode reservar espço em disco de forma desnecessária

VARCHAR - 10 poseções

	Tamanho variável em disco

	Vantagem: Por ser de tamanho variável ocupa apenas o espaço necessário em disco

	Desvantagem: Por ser de tamanho variável possui um meta dado com uma instrução de finalização do texto, o que produz, em relação ao CHAR, maior lentidão em pesquisas

						AULA: EDITANDO NOME DE TABELAS

Nessa aula vamos aprender a como editar o nome de tabelas já criadas dentro dos nossos bancos de dados já criados.

E por que conhecer o recurso de nomes de tabelas é algo interessante?
	Porque existirão situações em que você vai precisar modificar os nomes das tabelas da aplicação, isso pode acontecer por exemplo pq no momento da criação da tabela, o nome da tabela foi digitado da forma incorreta, ou até mesmo por uma mudança nos termos do banco de dados, de repente a aplicação cresceu, o bancos de dados normalmente acompanha esse crescimento e aí pode ser necessário mudar o nome da tabela por alguma razão.

Podemos fazer tal edição pelos recursos de interfaces visuais do phpMyAdmin, ou com instruções MysSQL da subcategoria DDL.

INSTRUÇÃO SQL:

	RENAME TABLE `nome_tabela_antiga` TO `nome_tabela_nova`;

Algumas intruções não refletem no phpMyAdmin porque realmente a aplicação não está preparado com isso, precisamos atualizá-las.

						AULA: INCLUINDO, EDITANDO E REMOVENDO COLUNAS DE TABELAS

ALTER TABLE (alterar tabela)

ADD - Permite a inclusão de uma nova coluna em uma tabela

CHANGE - Permite a alteração do nome de uma coluna e de suas propriedades, como por exemplo o tipo

DROP - Permite a remoção de uma coluna da tabela.

// Ainda estamos trabalhando com as estruturas que irão receber os dados.

INCLUSÃO DE UMA NOVA COLUNA

// É fundamental que o banco de dados esteja selecionado quando clicarmos nas instruções SQL.

	ALTER TABLE "nome_tabela" ADD COLUMN "nome_coluna" VARCHAR(5) NOT NULL;

	// O column é opcional.

EXEMPLO

	ALTER TABLE tb_cursos ADD COLUMN carga_horaria VARCHAR(5) NOT NULL;

MODIFICANDO COLUNA

	ALTER TABLE "nome_tabela" CHANGE "nome_coluna" 
	// Tudo isso foi feito para selecionarmos a coluna da respectiva tabela. Tudo em diante disso, estamos modificando a coluna...

EXEMPLO

	ALTER TABLE tb_cursos CHANGE carga_horaria  carga_hora INT(5) NULL;

	// mesmo modificando apenas o nome, precisamos indicar também o tipo de dado que a coluna irá receber

REMOVENDO

	ALTER TABLE "nome_tabela" DROP "nome_coluna";

EXEMPLO

	ALTER TABLE tb_cursos DROP carga_horaria;

	// Todos os registros inerentes à tabela serão eliminados de forma permanente.



						AULA: INSERT - INSERINDO DADOS EM TABELAS

Nessa aula vamos aprender a como podemos inserir registros dentro de tabelas que por sua vez estão dentro de bancos de dados que são geridos por gerenciador de bancos de dados como por exemplo o MySQL que roda sobre um sistema operacional.

Quando estamos trabalhando com a comunicação entre a nossa aplicação e o banco de dados, essa comunicação é feita por meio do MySQL. Nós encaminhamos instruções SQL para o banco de dados, para que ele execute essas instruções de acordo com o que é enviado pela aplicação. Imagine que temos um formulário web e queremos que os dados inseridos nele sejam enviados para o banco de dados, através de uma requisição, nós vamos encaminhar os dados do Front-End da aplicação para o Back-End da aplicação para que o Banck-End aí sim se comunique com o banco de dados através do SQL. Claro que ao fazer a submissão de um formulário web para ser persistido num banco de dados, naturalmente ninguém vai acessar o CLIENTE do SGBD para fazer essa inserção manual é importante que tudo isso seja feita por meio de instruções automáticas. Por essa razão, dominar o SQL que é uma linguagem super simples, é fundamental.

INSERINDO DADOS:

	INSERT INTO "nome_tabela" ('colunas') VALUE ('valores');

EXEMPLO

	INSERT INTO tb_cursos(ativo, carga_horaria, data_cadastro, id_curso, imagem_curso, investimento, nome_curso, resumo) VALUES (1, 35, '2022-07-27 18:30:50', 2, 'curso_angular.jpg', 575.86, 'Web Completo com JS, TS e Angular', 'Aprenda a criar aplicações incríveis com JavaScript, TypeScript e Angular');

	// Repare que as strings são delimitadas por aspas simples.

	// Os valores devem ter a mesma posição que as suas respectivas colunas.

	Não é possivel fazer o insert de dois registros em tabelas diferentes, é sempre um Inserts de cada vez.


						AULA: SELECT - CONSULTANDO DADOS

CONSULTA

	SELECT "colunas" FROM "tabela";

Outra possibilidade que temos para acessar registros em uma determinada tabela é utilizar o caractere coringa que é o asteriscos para seleção de todos os campos da tabela.

	SELECT * FROM tb_cursos;

É importante ressaltar que não é bom que utilizamos o asterisco pois ele seleciona grandes quantidades de registros sem necessidade, é aconselhável informar os registros de uma determinada tabela de forma implícita.

						AULA: FILTRANDO REGISTROS (WHERE)

Pra que serve um filtro?

	A cláusula WHERE indica para o sistema gerenciador de banco de dados que para aquela consulta que vamos realizar existem filtros que devem ser levados em consideração.

EXEMPLOS:

SELECT id_curso, nome_curso FROM tb_curso WHERE investimento < 500.00

SELECT id_curso, nome_curso FROM tb_curso WHERE investimento < 500.00 AND carga_horaria > 30

OPERADORES DE COMPARAÇÃO:	[...] WHERE investimento < 500.00

	= Valor da esquerda igual ao valor da direita

	< Valor da esquerda menor ao valor da direita

	<= Valor da esquerda menor ou igual ao valor da direita

	> Valor da esquerda maior ao valor da direita

	>= Valor da esquerda maior ou igual ao valor da direita

OPERADORES LÓGICOS:	[...] WHERE investimento < 500.00 AND carga_horaria > 30

	AND Todas as operações de comparação devem ser verdadeiras

	OR Pelo menos uma das operações de comparação deve ser verdadeira


						AULA: POPULANDO O BANCO DE DADOS COM REGISTROS PARA TESTES

Nessa aula apenas vamos criar uma tabela chamada tb_alunos com 100 registros para que possamos treinar os filtros que envolvem operadores de comparação e operadores lógicos.

Vamos criar querys automáticos para que a nossa tabela possa ser preenchida com valores aletórios para esse fim, para isso utilizamos a aplicação generatedata.com, mas o professor já fez esse trabalho colocando os registros no tb_alunos.txt para agilizar o processo.

CREATE TABLE tb_alunos (
  id_aluno int,
  nome varchar(255) default NULL,
  idade int default NULL,
  interesse varchar(255) default NULL,
  email varchar(255) default NULL,
  estado varchar(255) default NULL
);

INSERT INTO `tb_alunos` (`id_aluno`,`nome`,`idade`,`interesse`,`email`,`estado`) VALUES (1,"Jorden",47,"Esporte","vel.mauris.Integer@nec.net","DF"),(2,"Lacey",59,"Jogos","ligula.eu.enim@egetlaoreetposuere.com","SC"),(3,"Lillith",48,"Saúde","Curabitur@atvelitCras.org","MA"),(4,"Zephania",63,"Saúde","erat.vitae@loremtristiquealiquet.net","RS"),(5,"Scarlett",95,"Informática","facilisis.Suspendisse.commodo@placeratCrasdictum.org","MS"),(6,"Nash",39,"Música","Aliquam@Maurisquisturpis.org","BA"),(7,"Indigo",62,"Informática","mus.Proin@laoreet.co.uk","GO"),(8,"Bernard",77,"Esporte","ut@Craspellentesque.net","PA"),(9,"Cheyenne",78,"Música","vel.pede@liberoduinec.co.uk","PR"),(10,"Nerea",88,"Música","non@facilisisvitae.edu","PB"),(11,"Lucius",57,"Esporte","eu.erat@interdum.ca","PE"),(12,"Fallon",38,"Saúde","risus@Etiamimperdietdictum.net","MT"),(13,"Steven",35,"Música","tellus@netus.org","CE"),(14,"Paul",37,"Música","sollicitudin.adipiscing@magnaCras.edu","GO"),(15,"Bradley",31,"Música","massa.Vestibulum@vitaesemperegestas.com","AP"),(16,"Jeanette",46,"Informática","vitae@accumsannequeet.co.uk","MG"),(17,"Craig",40,"Informática","magna.et.ipsum@tellusid.edu","MS"),(18,"Maia",94,"Esporte","ac@tempusnon.co.uk","PB"),(19,"Harriet",16,"Jogos","ante.ipsum@maurissitamet.com","AL"),(20,"Finn",99,"Informática","metus.vitae@vitaerisusDuis.com","MT"),(21,"Rafael",71,"Esporte","adipiscing.elit.Etiam@vel.edu","MG"),(22,"Cynthia",85,"Esporte","Donec.nibh.Quisque@Sed.org","RN"),(23,"Evelyn",13,"Informática","lacus.Aliquam.rutrum@etrutrumeu.edu","MA"),(24,"Sybil",39,"Saúde","semper@nuncsed.com","ES"),(25,"Uriel",10,"Esporte","semper.pretium.neque@eumetusIn.ca","PB");
INSERT INTO `tb_alunos` (`id_aluno`,`nome`,`idade`,`interesse`,`email`,`estado`) VALUES (26,"Dakota",99,"Esporte","ipsum@etrutrumnon.co.uk","PB"),(27,"Stewart",31,"Saúde","natoque.penatibus.et@inhendrerit.org","CE"),(28,"Cruz",96,"Saúde","Cum.sociis.natoque@elementumloremut.org","RS"),(29,"Kadeem",57,"Informática","consectetuer@faucibusleoin.net","MS"),(30,"Wyatt",36,"Música","feugiat.non@dolorsitamet.net","SC"),(31,"Griffith",28,"Jogos","Lorem@elementumsem.com","RO"),(32,"Yvette",39,"Saúde","mauris@dignissim.com","RO"),(33,"Burton",14,"Esporte","leo.elementum.sem@arcuVestibulumante.edu","SC"),(34,"Tatum",4,"Saúde","eget.lacus@nequeInornare.com","PA"),(35,"Graham",88,"Informática","ac@necurna.com","ES"),(36,"Aretha",37,"Esporte","malesuada.augue@Nunc.com","ES"),(37,"Sloane",5,"Saúde","parturient@purusMaecenaslibero.net","CE"),(38,"Uriel",81,"Saúde","Praesent.interdum@enimnon.net","AL"),(39,"Cameran",61,"Esporte","sem.consequat@senectus.com","PR"),(40,"Chiquita",8,"Jogos","nisl.Quisque@utodio.co.uk","MA"),(41,"Tanek",40,"Esporte","nonummy@lectusNullamsuscipit.org","AL"),(42,"Bruno",3,"Jogos","semper.Nam@atpretium.ca","DF"),(43,"Winter",14,"Jogos","Quisque.nonummy@dolorNulla.ca","RS"),(44,"Jacob",82,"Música","nec.eleifend.non@sapien.ca","RR"),(45,"Kuame",98,"Esporte","placerat@ametorci.ca","PR"),(46,"Orli",74,"Saúde","eu.erat.semper@dolorsitamet.co.uk","ES"),(47,"Amber",24,"Informática","eleifend.non@quamvelsapien.org","AL"),(48,"Roary",77,"Saúde","quis.pede.Suspendisse@Duisa.com","SE"),(49,"Octavius",28,"Jogos","euismod.in.dolor@posuere.edu","PA"),(50,"Isabella",54,"Informática","eu@euarcuMorbi.ca","RR");
INSERT INTO `tb_alunos` (`id_aluno`,`nome`,`idade`,`interesse`,`email`,`estado`) VALUES (51,"Driscoll",70,"Informática","sem@malesuada.com","SP"),(52,"Brendan",45,"Informática","arcu.et.pede@magna.com","SC"),(53,"Quon",18,"Informática","elit@adipiscingnon.org","AP"),(54,"Rajah",48,"Informática","magna.tellus@Quisquefringilla.org","RJ"),(55,"Lewis",32,"Informática","faucibus@vulputate.com","PA"),(56,"Ronan",34,"Esporte","tellus.non@eleifend.com","CE"),(57,"Baxter",72,"Esporte","enim.sit@urnanec.ca","DF"),(58,"Kyla",6,"Esporte","facilisis.eget@sociosquadlitora.net","AM"),(59,"Ava",54,"Jogos","velit@acmattis.edu","RN"),(60,"Leonard",59,"Música","fermentum.arcu@consequatenim.ca","MS"),(61,"Byron",17,"Música","Pellentesque.habitant.morbi@sapienNunc.edu","MT"),(62,"Roary",52,"Jogos","nec.eleifend.non@velvenenatis.org","GO"),(63,"Amery",89,"Informática","mauris.aliquam.eu@Proindolor.net","PA"),(64,"Adele",40,"Saúde","scelerisque@velvenenatisvel.com","RR"),(65,"Ronan",14,"Saúde","posuere.cubilia@Donecnonjusto.co.uk","RJ"),(66,"Marny",53,"Saúde","convallis.in.cursus@blanditatnisi.com","PA"),(67,"Camden",31,"Música","magna@mauriseu.edu","RJ"),(68,"Yoko",13,"Música","dolor@vehiculaet.com","AM"),(69,"Ina",71,"Informática","gravida.sagittis@tempusscelerisquelorem.com","AL"),(70,"Tyler",3,"Esporte","Proin.dolor.Nulla@nascetur.org","PI"),(71,"Destiny",19,"Saúde","augue.id@elementum.edu","MG"),(72,"Glenna",82,"Jogos","dui@interdumligula.ca","AP"),(73,"Buffy",55,"Esporte","dictum.eu@placeratvelitQuisque.net","MA"),(74,"Hashim",27,"Música","est.congue@enim.org","MA"),(75,"Hiram",67,"Saúde","nunc.sit.amet@nibhPhasellus.co.uk","RN");
INSERT INTO `tb_alunos` (`id_aluno`,`nome`,`idade`,`interesse`,`email`,`estado`) VALUES (76,"Kenneth",50,"Esporte","a.nunc.In@Integermollis.edu","AL"),(77,"Ariel",9,"Jogos","Etiam.vestibulum.massa@egestas.edu","PA"),(78,"Barrett",24,"Informática","fringilla.mi@liberoIntegerin.com","PA"),(79,"Kato",25,"Música","cursus.in.hendrerit@eu.org","BA"),(80,"Lance",50,"Saúde","Nullam@necurna.net","CE"),(81,"Porter",50,"Jogos","ultrices.mauris@nequesed.org","PA"),(82,"Zeus",26,"Informática","hymenaeos@Integereu.net","RR"),(83,"Oleg",36,"Informática","Nam@morbitristiquesenectus.ca","AL"),(84,"Erin",25,"Saúde","ligula@Nullam.edu","TO"),(85,"Wade",61,"Esporte","odio.Aliquam.vulputate@egestas.edu","MS"),(86,"Ross",92,"Música","tortor.at.risus@ac.edu","DF"),(87,"Martina",24,"Música","Cras@lacusAliquam.com","MS"),(88,"Rowan",75,"Saúde","erat@afelisullamcorper.com","RO"),(89,"Aristotle",22,"Esporte","at.auctor@Utnecurna.net","PI"),(90,"Bernard",24,"Saúde","placerat.orci.lacus@vitaesemperegestas.edu","RJ"),(91,"Teegan",9,"Música","id@Fuscealiquam.co.uk","DF"),(92,"Graiden",7,"Jogos","ante.dictum@nibhAliquam.co.uk","AL"),(93,"Alec",50,"Música","vestibulum.neque.sed@nislQuisque.co.uk","PE"),(94,"Savannah",61,"Jogos","odio.a.purus@nequeSedeget.co.uk","ES"),(95,"Rafael",45,"Informática","a@dolorsit.net","PB"),(96,"Clementine",32,"Saúde","dictum@Aliquamerat.edu","RS"),(97,"Tasha",53,"Esporte","in@justoProin.co.uk","AC"),(98,"Hector",83,"Música","Class.aptent@et.co.uk","AM"),(99,"Tara",95,"Jogos","Donec.porttitor.tellus@nonfeugiat.co.uk","DF"),(100,"Charissa",50,"Informática","orci@elementumduiquis.ca","AP");


						AULA: SELECT - FILTRO COM O OPERADOR BETWEEN

WHERE							WHERE
	idade >= 18 AND idade <= 21			---------->		idade BETWEEN 18 AND 21

WHERE							WHERE
	data >= '2018-07-01' AND data <= '2018-07-31'	---------->		data BETWEEN '2018-07-01' AND '2018-07-31'

O operador Between otimiza certos filtros no dia a dia.

Tal operador pode ser utilizado quando precisamos filtrar registros cujo o valor de uma determinada coluna está entre um intervalo específico, sendo que os valores contidos nessa coluna pode ser do tipo Number ou do tipo Date.

O between na prática acaba funcionando como uma sintaxe mais fácil de estabelecer filtros com a finalidade de estabelecer uma pesquisa de intervalos.

		
						AULA: SELECT - FILTRO COM O OPERADOR IN

WHERE
	interesse = 'jogos' OR interesse = 'Musica' OR interesse = 'Esporte'

	|
	|
	|
	V

WHERE
	interesse IN('jogos', 'musica', 'esporte')

Nessa aula nós vamos aprender a como podemos utilizar o operador IN para a realização de filtros de registros com base numa especificação de uma lista de possibilidades.

Podemos ter a possibilidade de escolher as listas que não devem ser consideradas no retorno da consulta, para fazer isso, basta informar NOT IN:

	SELECT * FROM `tb_alunos` WHERE interesse NOT IN('jogos', 'esporte', 'musica');


						AULA: SELECT - FILTROS COM O OPERADOR LIKE

Permite realizar filtros com base em uma pesquisa de caracteres dentro de uma coluna textual

Caracteres curingas:

	% Indica que pode haver a existência de qualquer conjunto de caracterer no texto

		WHERE nome LIKE '%e'
			//Traga qualquer registro que possua um conjunto de caracteres que finalizem com a letra 'e'.
		WHERE nome LIKE '%a%'
			//Traga qualquer registro que possua um conjunto de caracteres que tenha dentro sua cadeia de caracteres a letra 'e'.
		WHERE nome LIKE 'C%'
			//Traga qualquer registro que possua um conjunto de caracteres que começam com a letra 'e'.

	// A diferença do curinga para o underline é que ele é mais exato. Ou seja, é uma posição explícita que é mais definida, um underline, significa que terá apenas um caractere.

	_ Indica que pode haver a existência de um ou mais caracteres em uma posição específica do texto

		WHERE nome LIKE '_riel'
		WHERE nome LIKE '_ru_'
		WHERE nome LIKE 'I__'
			//O underline duas vezes significa que depois da letra 'i' terá dois caracteres indeifinidos.

----------------

	WHERE nome LIKE 'Evelyn'

	WHERE nome LIKE '%tt_'
		// Nada impede que os caracteres especiais sejam combinados em ums instrução.


						AULA: SELECT - ORDENANDO RESULTADO

SELECT
	<coluna(s)>
FROM
	<tabela(s)>
WHERE
	<filtro(s)>
ORDER BY
	idade ASC, nome DESC

	// ASC == Ascending (valor default)
	// DESC == Descending

Nós vamos poder ordenar os nossos registros das nossas consultas através da palavra reservada ORDER BY.


						AULA: SELECT - LIMITANDO RETORNO

SELECT
	<coluna(s)>
FROM
	<tabela(s)>
WHERE
	<filtro(s)>
ORDER BY
	<ordenação>
LIMIT			ou 		[...]LIMIT			// 1° parâmetro = OFFSET
	5					2,5		// 2° parâmetro = LIMIT
OFFSET
	2

//offset funciona dessa maneira: retorne os registros a partir do registro de posição 0, ou seja, ele funciona como um ponto de partida.

	// Offset funciona como um deslocamento, ou seja, a apartir de qual registros devemos retornar uma determinada quantidade de registros.

Podemos limitar a quantidade de retorno dos registros com a palavra reservada LIMIT.

Esse tipo de recurso é muito utilizado quando a tabela possui muitos registros, e nós queremos limitar a quantidade de registros que serão apresentados para o usuário final, como por exemplo em paginações em que nós podemos listar uma determinada quantidade a princípio e apartir de uma paginação o usuário pode seguir para a próxima relação de registros sequentes.


						AULA:  SELECT - FUNÇÕES DE AGREGAÇÃO PARTE 1: MAX, MIN e AVG

SELECT
	funções de agregação
	
	// MIN(<coluna>) - Retorn o menor valor de todos os registros com base em uma coluna

	// MAX(<coluna>) - Retorna o maior valor de todos os registros com base em uma coluna

	// AVG(<coluna) - Retorna a média de todos os registros com base em uma coluna

FROM
	<tabela(s)>
WHERE
	<filtro(s)>

Para entendermos a aula e o seu conteúdo faz-se necessário baixar o documento de texto querys_necessarias.txt

QUERYS_NECESSARIAS.TXT

/*
CREATE TABLE tb_cursos (
  id_curso INT(11) NOT NULL,
  imagem_curso VARCHAR(100) NOT NULL,
  nome_curso CHAR(50) NOT NULL,
  resumo TEXT NULL,
  data_cadastro DATETIME NOT NULL,
  ativo BOOLEAN DEFAULT 1,
  investimento FLOAT(8,2) DEFAULT 0,
  carga_horaria INT(5) NULL  
);
*/


REMOVE TODOS OS REGISTROS CONTIDOS EM UMA TABELA:

TRUNCATE tb_cursos;

INSERT INTO tb_cursos(id_curso, imagem_curso, nome_curso, resumo, data_cadastro, ativo, investimento, carga_horaria) VALUES (1, 'curso_node.jpg', 'Curso Completo do Desenvolvedor NodeJS e MongoDB', 'Resumo do curso de NodeJS', '2018-01-01', 1, 159.99, 15), (2, 'curso_react_native.jpg', 'Multiplataforma Android/IOS com React e Redux', 'Resumo do curso de React Native', '2018-02-01', 1, 204.99, 37), (3, 'angular.jpg', 'Desenvolvimento WEB com ES6, TypeScript e Angular', 'Resumo do curso de ES6, TypeScript e Angular', '2018-03-01', 1, 579.99, 31), (4, 'web_completo_2.jpg', 'Web Completo 2.0', 'Resumo do curso de Web Completo 2.0', '2018-04-01', 1, 579.99, 59), (5, 'linux.jpg', 'Introdução ao GNU/Linux', 'Resumo do curso de GNU/Linux', '2018-05-01', 0, 0, 1)


----------------------------

// Baixe NotePad++ para que nós possamos testar e visualizar melhor os códigos de C# aprendidos no outro curso, assim, podemos facilmente visualizar os códigos pois a aplicação suporta cores de IDEs.

							AULA: FUNÇÕES DE AGREGAÇÃO PARTE 2: SUM E COUNT

SELECT
	funções de agregação

	// SUM (<coluna>) - Retorna a soma dos valores de todos os registros com base em uma coluna

	// COUNT(*) - Retorna a quantidade de todos os registros de uma tabela
FROM
	<tabela(s)>
WHERE
	<filtro(s)>

// As funções de agregação podem ser feitas para uma coluna específica ou para todas as colunas mas para entender como tudo isso funciona, nós precisamos entender ainda como que nós podemos agrupar registros e tabém a como selecionar registros de formas distintas, basicamente falando, as funções de agregações podem ser usadas de forma mais complexas assim que aprendermos essas duas possibilidades 


							AULA: AGRUPANDO SELEÇÃO DE REGISTROS (GROUP BY)

O Group By é muito utilizado em conjunto com as funções de agregação para responder as perguntas como por exemplo:

	Qual é total de vendas por mês?

	Qual é a quantidade total de alunos por curso?

	Qual a quantidade detotal de cliques por anúncio?

	Qual é o total de reclamações por categoria?

	Qual é o total de chamadas por número telefônico?

Repare que de um lado temos uma função de agregação como sendo uma soma ou um totalizador, e do outro lado nós temos uma relação agrupada seja de meses, de tipos, de números, por categoria, enfim.

GROUP BY é muito utilizado para criação de relatórios que apresentem resultados com base em registros agrupados, como por exemplo, os famosos indicadores em que a a partir de um determinado grupo de informações nós realizamos funções aritméticas sobre o conjunto de registros daqueles respectivos grupos.


SELECT
	<coluna(s)>
FROM
	<tabela(s)>
WHERE
	<filtro(s)>
GRUP BY
	agrupmento
ORDER BY
	<ordenação>
LIMIT
	<offset>, <limit>

// É importante notar a posição do GROUP BY.

--------------------

GROUPBY
	Agrupa os elementos com base em uma ou mais colunas cujos valores seja iguais. Permite realizar funções de agregação em cada subconjunto agrupado de registros.

EXEMPLO DE USO

SELECT 
	interesse, count(*) AS total_por_interesse
FROM 
	`tb_alunos` 
GROUP BY
	interesse

	// Nesse exemplo estamos chamando os dados da coluna que são diferentes, repare que isso é feito apenas citando a coluna no GROUP BY, ou seja, é um valor padrão.
	// Repare que temos uma nova instrução no SELECT, "AS" que significa Alias, estamos atribuindo um nome para a nova coluna que reberá o total de cada tipo de interesse, por exemplo:

interesse	                 | total_por_interesse
---------------------------------------------------------
Esporte		22
Informática	22
Jogos		18
Música		15
Saúde		22

							AULA: FILTRANDO SELEÇÕES AGRUPADAS (HAVING)


SELECT
	<coluna(s)>
FROM
	<tabela(s)>
WHERE
	<filtro(s)>
GROUP BY
	<agrupamento>
HAVING
	filtro(s) sobre agrupamento

	// filtro realizado sobre o resultado dos agrupamentos (GROUP BY)
ORDER BY
	<ordenação>

	// O Group By existe sem o having, mas o Having não existe sem o Group By.
LIMIT
	<offser>, <limit>

// O Having ele atua sobre o resultado de uma consulta com colunas agrupadas.

EXEMPLO DE USO:

SELECT 
   	estado, COUNT(*) AS total_registros_por_estado
FROM 
	`tb_alunos` 
GROUP BY
	estado
HAVING 
	total_registros_por_estado >= 5

// Estamos informando que queremos um número de possibilidades de registros existentes para cada estado existente, e apenas retornará o resultado os estado que tiverem um total de registros por estado maior que 5.

// Mas o filtro não necessariamente precisa ser sobre a função de agregação, nós podemos fazer esse filtro sobre a coluna de agrupamento.

SELECT 
   	estado, COUNT(*) AS total_registros_por_estado
FROM 
	`tb_alunos` 
GROUP BY
	estado
HAVING 
	estado IN('SP', 'MG');

-------------------------------------------

// Podemos também aplicar o filtro em mais de uma coluna.

SELECT 
   	estado, COUNT(*) AS total_registros_por_estado
FROM 
	`tb_alunos` 
GROUP BY
	estado
HAVING 
	estado IN('CE', 'SC') AND total_registros_por_estado > 4;

---------------------------------------------

Como que o WHERE se encaixa nesse contexto?

O operador WHERE está em um nível anterior de precedência da execução dos filtros.

SELECT 
   	estado, COUNT(*) AS total_registros_por_estado
FROM 
	`tb_alunos` 
WHERE
	interesse != 'Esporte'
GROUP BY
	estado
HAVING 
	total_registros_por_estado > 3;

// Repare que o Group By se comporta como sendo a segunda camada de um filtro já feito pelo WHERE.

É fundamental compreender a precedência de cada bloco para que seja proporcionado um novo resultado final.


							AULA: UPDATE - ATUALIZANDO REGISTROS

Nessa aula nós vamos aprender a como podemos atualizar os registros que estão contidos dentro de tabelas e nossos banco de dados. Para fazer isso, nós vamos utilizar a instrução UPDATE que faz parte do subconjunto do SQL conhecido como DML. Portanto, estamos trabalhando agor com outra instrução de manipulação de dados.

/*DML - Data Manipulation Language - Linguagem de manipulção de dados*/

UPDATE
	<tabela>
SET
	<coluna> = <valor>, <coluna> = <valor>, <coluna> = <valor>
WHERE
	<filtro(s)>

// É importante ressaltar que o WHERE filtra qual(is) registro(s) serão afetados pelo UPDATE. Caso o WHERE seja omitido, todos os registros da tabela serõ atualizados, ou seja, aquela(s) coluna(s) daquela respectiva tabela passarão a ter o mesmo valor que estão sendo aplicados aqui na instrução SET.

EXEMPLO DE USO:

UPDATE 
	tb_alunos 
SET 
	nome = 'João' 
WHERE 
	id_aluno = 18

-------------------------------------

Nada impede que no processo de atualização mais de um campo seja atualizado

EXEMPLO DE USO:

UPDATE 
	tb_alunos 
SET 
	nome = 'José', idade = 25, email = 'jose@gmail.com' 
WHERE 
	id_aluno = 18

-------------------------------------

Outra possibilida que temos é que no WHERE nós podemos utilizar mais de uma possibilidade de filtro.


							AULA: DELETE - EXCLUINDO REGISTROS

Vamos aprender a como podemos remover registros dentro de tabelas. Trata-se de mais uma instrução da subcategoria do SGBD chamada DML (Data Manipulation Language).

DELETE FROM
	<tabela>
WHERE
	<filtro(s)>

A cláusula WHERE indica quais registros devem ser afetados pela instrução DELETE. Caso o Where não esteja presente na remoção de registros dessa tabela, será apagado TODOS os registros dessa respectiva tabela.

É sempre importante antes de Atualizarmos ou Removermos algo da nossa tabela, um SELECT para vermos o que será alterado dessa respectiva tabela.

Apenas podemos recuperar registros perdidos é através de um backup.

Geralmente, nós não realizamos a remoção dos registros, a instrução DELETE, claro, é usada em muitas situações mas normalmente nós optamos por uma atualização no registro, modificando alguma coluna que represente o estado daquele registro, ou seja, se aquele registro está ativo ou inativo, de forma análoga ao que foi feito aqui na tabela tb_cursos. Tudo claro depende, de uma análise prévia para verificar se aqueles registros são importantes a ponto de serem mantidos para fins históricos mesmo quando não mais necessários.


						AULA:  INTRODUÇÃO AO RELACIONAMENTO ENTRE TABELAS, CHAVE PRIMÁRIA E ESTRANGEIRA


A partir dessa aula, daremos início ao estudo do relacionamento entre tabelas, o nome de BANCOS RELACIONAIS nao é por acaso, Apesar de implementarmos tabelas específicas com fins bem específicos, onde temos a representação de entidades com seus respectivos atributos, que constituem os registros, na prática é importante efetuarmos o relacionamento entre tais tabelas. O relacionamento entre as tabelas consiste em tentar imitar a relação entre as coisas que existem no mundo real, levando essas relações para os nossos registros.

Tipos de relacionamentos:

	Um para Um

	Um para Muitos

	Muitos para Muitos

Chave primária

	// Seu objetivo é servir como um identificador único para cada registro dentro de uma tabela, de modo que esse identificador não se repita em nenhum momento para nenhum outro registro. A chave primária é muito utilizada para seleção de registros, atualizção de registros, remoção de registros e principalmente, para criação de relacionamentos consistentes entre diferentes tabelas. 

	// Quando a chave primária é constituida por dois ou mais campos de um determinado registro dentro de uma determinada tabela, damos a essa chave primária, o nome de chave primária composta.

Chave estrangeira

	// Já a chave estrangeira é uma referência da chave primária de outra tabela, a partir de uma chave estrangeira, por exemplo, id_curso na tabela tb_disciplinas, podemos localizar o curso a disciplina ou disciplinas fazem referência, lá em tb_cursos.


						AULA: PROJETO LOJA VVIRTUAL - RELACIONAMENTO UM PARA UM

 O objetivo do projeto é criar uma estrutura de dados que suporte uma aplicação com a proposta de venda de produtos pela internet. Vamos focar apenas no banco de dados

Nessa ula iremos aprender o relacionamento de Um para Um. 

Digamos que a nossa necessidade de negócio seja armazenar a descrição de um determinado produto, o valor desse respectivo produto, algumas fotos para aquele produto e também uma descrição técnica desse produto. Como podemos preparar o nosso banco de dados para receber essas informações? Existem muitas formas de se fazer isso, nessa aula, para atender essa necessidade de negócio dentro de um contexto de relacionamento de tabelas de Um para Um, nós vamos criar duas tabelas:

	TB_PRODUTOS
		armazena a descrição do produto
		armazena o valor do produto

	TB_DESCRICOES_TECNICAS
		armazena a descrição tecnica

	// Por enquanto, não remos falar a respeito das fotos. Até porque o tipo de relacionamento entre tabelas iria mudar, e a proposta da aula não é essa.

	--------------

			Diagrama Entidade Relacionamento

tb_produtos			---------------		tb_descricoes_tecnicas

id_produto: INTEGER						id_descricao_tecnica: INTEGER
produto: VARCHAR(200)					id_produto: INTEGER(FK)
valor: FLOAT						descricao_tecnica: TEXT
							tb_descricoes_tecnicas_FKIndex1
								id_produto

// primary Key: id_produto					// primary key: id_descricao_tecnica
							// Fore Key: id_produto

Cada descrção tecnica precisa estar associado a um produto, o que caracteriza o nosso relacionamento de um para um. Um produto, possui uma descrição técnica

// Aplicativo para fazer diagramas:
// 	DB DESIGNER

A coluna id_produto como sendo a primary Key receberá não apenas valores numéricos mas também dados de identificações únicos para cada registro. Logo, os valores contidos dentro da coluna id_produto não pode em nenhum momento se repetir. Para fazer com que o SGBD impeça a inclusão de valores duplicados para esse identificador, nós precisamos de forma explícita indicar para o SGBD, ou no momento da construção da tabela, ou depois, a partir de uma alteração da tabela, qual que é o campo que vai ser a nossa chave primária.

EXEMPLO:

CREATE TABLE tb_produtos(
	id_produto INT NOT NULL PRIMARY KEY
)

Nós podemos através da aplicação, gerenciar qual será identificador único que vai ser incluído dentro dessa coluna no momento da inserção do registro, porém isso dá um pouco de trabalho, perceba que antes da inserção de qualquer registro, nós iríamos ter que pesquisar dentro dessa tabela, quais são os IDs que estão em uso e provavelmente inserir um ID posterior, nós precisaríamos de uma lógica para evitar duplicar essa informação e registro seguintes, porém, o próprio SGBD, nos dá a possibilidade de AUTO_INCREMENT ( auto incrementar). 

Campos do Auto_increment são gerenciados pelo próprio banco de dados de modo que, ao inserir um novo registro, a informação que será atribuido aquela coluna, será com base no último valor inserido + 1. Isso significa que a função AUTO_INCREMENT, automaticamente, vai incrementando o valor contido nessa coluna de um em um.


CRIAÇÃO DA TABELA tb_produtos

CREATE TABLE tb_produtos(
	 id_produto INT NOT NULL PRIMARY KEY AUTO_INCREMENT, 
	produto VARCHAR(200) NOT NULL, 
	valor FLOAT(8,2) NOT NULL
 );

-----------------------------------

CRIAÇÃO DA TABELA TB_DESCRICOES_TECNICAS

CREATE TABLE tb_descricoes_tecnicas(
	 id__descricao_tecnica INT NOT NULL PRIMARY KEY AUTO_INCREMENT, 
	id_produto INT NOT NULL, 
	descricao_tecnica TEXT NOT NULL,
	FOREIGN KEY(id_produto) REFERENCES tb_produtos(id_produto)
 );

// Repare na instrução de FOREIGN KEY que nos possibilita marcar a chave estrangeira. Ela espera um parâmetro, esse parâmetro é o nome da coluna dentro da tabela que será utilizada como chave estrangeira. Na sequência, precisamos informar qual é a referência de chave estrangeira, ou seja, da onde essa chave está vindo e para onde essa chave vai, que no caso é a coluna id_produto. Referenciamos a tabela de produtos e por parâmetro, passamos a nossa coluna.

// A chave estrangeira e a chave primária não precisam necessariamente ter o mesmo nome.


						AULA: PROJETO LOJA VIRTUAL - RELACIONAMENTO UM PARA UM (POPULANDO TABELAS)

RECURSO DA AULA:

querys_necessarias.txt

// tb_produtos

INSERT INTO tb_produtos(produto, valor) VALUES ('Notebook Dell Inspiron Ultrafino Intel Core i7, 16GB RAM e 240GB SSD', 3500.00);

INSERT INTO tb_produtos(produto, valor) VALUES ('Smart TV LED 40" Samsung Full HD 2 HDMI 1 USB Wi-Fi Integrado', 1475.54);

INSERT INTO tb_produtos(produto, valor) VALUES ('Smartphone LG K10 Dual Chip Android 7.0 4G Wi-Fi Câmera de 13MP', 629.99);

// tb_descricoes_tecnicas

INSERT INTO tb_descricoes_tecnicas(id_produto, descricao_tecnica) VALUES (1, 'O novo Inspiron Dell oferece um design elegante e tela infinita que amplia seus sentidos, mantendo a sofisticação e medidas compactas...');

INSERT INTO tb_descricoes_tecnicas(id_produto, descricao_tecnica) VALUES (2, 'A smart TV da Samsung possui tela de 40" e oferece resolução Full HD, imagens duas vezes melhores que TVs HDs padrão...');

INSERT INTO tb_descricoes_tecnicas(id_produto, descricao_tecnica) VALUES (3, 'Saia da mesmice. O smartphone LG está mais divertido, rápido, fácil, cheio de selfies e com tela HD de incríveis 5,3"...');

----------------------------

É importante notar que estamos informando os valores da chave estrangeira id_produto na tabela descrições tecnicas, ou seja, faz-se necessário informar o valor dessa coluna para fazer referência com a outra tabela.


						AULA: PROJETO LOJA VIRTUAL - RELACIONAMENTO UM PARA MUITOS

Agora sim, vamos integrar as nossas imagens na nossa aplicação, ou seja, vamos criar uma nova tabela que faz relacionamento Um para Muitos com tb_produtos.

RELACIONAMENTO UM PARA UM

	Um produto possui apenas uma descrição técnica, vimos que esse tipo de relacionamento, não é comum no dia a dia.

RELACIONAMENTO UM PARA MUITOS

	Cada produto, pode ter, uma ou N imagens relativas ao produto, definindo o relacionamento como sendo Um para Muitos. Repare que esse tipo de relacionamento é muito comum no dia a dia, é um tipo de relacionamento bastante frequente, por exemplo: Um país tem vários estados, um estado tem várias cidades, um prédio tem vários andares, uma casa tem vários cômodos.

id_produtos continua sendo a chave estrangeira de tb_imagens.

Quando nós tratamos de imagens, áudios, vídeos, o que armazenamos no banco de dados é na verdade o caminho até aquele arquivo no sistema operacional ou na Internet. Ou seja, o arquivo digital não é armazenado no banco, nós guardamos apenas a referência, o nome, o path até aquele arquivo.

EXEMPLO DE UM PARA MUITOS

INSERT INTO tb_imagens(id_produto, url_imagem) VALUES
	(1, 'notebook_1.jpg'),
   	(1, 'notebook_2.jpg'),
    	(1, 'notebook_3.jpg');

INSERT INTO tb_imagens(id_produto, url_imagem) VALUES (2, 'smarttv_1.jpg'), (2, 'smarttv_2.jpg');

INSERT INTO tb_imagens(id_produto, url_imagem) VALUES(3, 'Smartphone_1.jpg');

// Repare que estamos atribuindo três imagens para um único produto.


						AULA: PROJETO LOJA VIRTUAL - RELACIONAMENTO MUITOS PARA MUITOS

Imagine agora que além do produto, a nossa aplicação também tem um recurso de cadastro de clientes e permite claro que clientes realizem pedidos, sendo que os pedidos evidentemente serão compostos por produtos. Na prática nós temos que, um cliente pode realizar muitos pedidos e um pedido pode ter muitos produtos, mas mais do que isso o mesmo produto pode estar presente em muitos pedidos diferentes. Então repare que entre produto e pedido nós temos uma relação de muitos para muitos.

Para estabelecer um relacionamento de Muitos para Muitos, nós precisamos criar uma tabela auxiliar, uma tabela que vai guardar esse relacionamento, para tornar esse conceito um pouco mais tangível, vamos focar agora em desenvolvimento dessas tabelas e relacionamentos. E na próxima aula, nós faremos inserts nessas tabelas e também, faremos uma revisão de como esse relacionamento de muitos para muitos funciona.

A tabela que é proveniente do relacionamento de muitos para muitos entre a tb_pedidos e tb_produtos possui apenas as chaves estrangeiras dessas respectivas tabelas.

FUNÇÕES NOVAS VISTAS NA AULA:

	data_hora DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP

// A Função Current_Timestamp retorna a data e a hora corrente do SGBD.


						AULA: INTRODUÇÃO AS JUNÇÕES (JOINS) ENTRE TABELAS

Só podemos pensar no JOIN depois que passarmos pelos relacionamentos que podem ser Um para Um, Um para Muitos e/ou Muitos para Muitos

A partir da junção entre duas ou mais tabelas temos condições de formar consultas mais avançadas. Basicamente falando, as junções nos permite conectar registros de tabelas diferentes, formando com isso, um resultado de pesquisa composto, ou seja, a consulta irá retornar registros compostos por diversas colunas de diversas tabelas diferentes, desde que tais tabelas possuam registros que se relacionam de alguma forma. Geralmente, utilizamos como referência para as junções, os índices das tabelas tais como chaves primárias e/ou chaves estrangeiras, mas isso não é necessariamente obrigatório, havendo um relacionamento de colunas de registros de tabelas diferentes, é possível, através das junções, explorar esses relacionamentos para obter resultados de consultas mais avançadas.

PRINCIPAIS JUNÇÕES

	LEFT JOIN

	RIGHT JOIN

	INNER JOIN

						AULA: JOIN - Junção à esquerda (LEFT JOIN)

LEFT JOIN

Relaciona todos os registros da tabela à esquerda + CASO EXISTA, todos os registros da tabela à direita.

Nesse momento nós podemos através do que já conhecemos responder a perguntas como: Quais são os clientes? Quais são as imagens? quais são os pedidos? Quais são os produtos? Quais são as inscrições técnicas? Enfim, através de consultas simples utilizando a instrução SELECT, nós podemos facilmente ter acesso a essas informações, mas como por exemplo eu poderia através de um único SELECT recuperar todos os clientes junto com seus respectivos pedidos? Bom, quando nós temos questões que envolver mais do que apenas uma única tabela, nós temos o cenário em que as junções de tabelas serão necessárias, os tipos de junções nesse caso irão influenciar a resposta, mas de qualquer forma, teremos que juntar tabelas para obter as respostas necessárias.

EXEMPLOS DE USO:

SELECT
	*
FROM
	tb_clientes LEFT JOIN tb_pedidos

No momento em que estabelecemos uma junção à esquerda, nós estamos falando que TODOS os registros da tabela à esquerda serão retornados na nossa consulta, e todos os registros da tabela à direita, CASO EXISTAM, serão retornados também. Para que haja uma junção entre tabelas é preciso estabelecer um pivô de relacionamento entre os registros dessas tabelas, que no caso são as chaves.

---------------

SELECT
	*
FROM
	tb_clientes LEFT JOIN tb_pedidos ON (tb_clientes.id_cliente = tb_pedidos.id_cliente)

// Vamos ver nesse exemplo que os registros de produtos se repetem de acordo com os registros de imagens, como temos três imagens para o produto 1, será retornado para nós 3 vezes o mesmo produto.

Perceba que, agora, estamos estabelecendo essa relação, entre a coluna id_cliente da tabela tb_clientes com a coluna id_cliente da tabela tb_pedidos. E na sequência, estamos estabelecendo a prioridade do resultado desse relacionamento. Enquanto depois do 'ON', indicamos como os registros se relacionam, antes do 'ON' indicamos como será feito o retorno desses registros, em que a tabela da esquerda será prioritária em relação à tabela da direita. Novamente, queremos todos os registros da tabela à esquerda, e caso exista, nós queremos também os registros da tabela à direita onde o relacionamento seja satisfeito.

É importante notar que o modo de relacionamento só pode ser feito entre chaves (estrangeira / primária)


							AULA: JUNÇÃO À DIREITA (RIGHT JOIN)

Relaciona todos os registros d tabela à direita + CASO EXISTA, todos os registros da tabela à esquerda.

EXEMPLOS DE USO:

SELECT * FROM tb_clientes LEFT JOIN tb_pedidos ON (tb_clientes.id_cliente = tb_pedidos.id_cliente);


							AULA: JUNÇÃO INTERNA (INNER JOIN)

INNER JOIN

	Relaciona todos os registros da tabela à direita e à esquerda, onde exista o relacionamento entre registros.


							AULA: ALIAS - APELIDANDO TABELAS


O recurso de apelidar tabelas é muito simples, mas também é muito útil, principalmente, quando estamos tratando muitas tabelas ao mesmo tempo.

para apelidar uma tabela, nós utilizamos a palavra reservada AS e na sequência, aplicamos um apelido.

EXEMPLO DE USO:

SELECT
	*	
FROM 
	tb_produtos AS p LEFT JOIN tb_descricoes_tecnicas AS dtON (p.id_produto = dt.id_produto)

----------------

SELECIONANDO APENAS O QUE QUEREMOS

SELECT
	p.id_produto,
   	p.produto,
    	p.valor,
    	dt.descricao_tecnica
FROM 
	tb_produtos AS p LEFT JOIN tb_descricoes_tecnicas AS dt ON (p.id_produto = dt.id_produto)

-------------------

COLOCANDO FILTROS E ORDENANDO

SELECT
	p.id_produto,
   	p.produto,
    p.valor,
    dt.descricao_tecnica
FROM 
	tb_produtos AS p LEFT JOIN tb_descricoes_tecnicas AS dt ON (p.id_produto = dt.id_produto)
WHERE
	p.valor >= 500
ORDER BY
	p.valor ASC


							AULA: INTRODUÇÃO AO AJAX


INTRODUÇÃO AO AJAX

ACRÔNIMO DE ASYNCHRONOUS JAVASCRIPT AND XML (JavaScript e XML Assíncronos)

Uma metodologia de programação que possibilita a comunicação assíncrona entre front-end e back-end de aplicações Web

Inicialmente disponibilizado na versão 4.0 do Internet Explorer

Potencializou a criação do conceito de web 2.0

// O Ajax é na verdade uma técnica de programação que utiliza tecnologia JavaScript para realizar dentre outras coisas, a comunicação Assíncrona entre o Back-end e o Front-End de aplicações Web.

No princípio, a comunicação entre o front-end e back-end de aplicações Web utilizando a técnica de requisições Assíncrona do AJax era prioritariamente feita pela troca de dados no formato XML, por isso o seu nome JavaScript e XML. Porém, atualmente, o formato de dados mais utilizado para a comunicação entre o front-end e o back-end de aplicações Web é o formato JSON, isso porque o JSON é uma notação ainda mais enxuta que o XML, portanto mais leve e além disso, o formato JSON é suportado nativamente pelo JavaScript e também por outras linguagens de programação, inclusive linguagens de Back-End, facilitando portanto, o parse de objetos para JSON e JSON para objetos.

Siglas que geram algumas dúvidas:

	AJAX é uma metodologia de programação, uma forma de se pensar e implementar as soluções. Geralmente de forma assíncrona

	XML E JSON são na verdade, apenas notações, ou seja, são formas de escritas, essas formas de escrita viabilizam a comunicação entre o front-end e o back-end de aplicações Web. Nós escrevemos alguma coisa, ou utilizando a notação XML, ou utilizando a notação JSON e através do AJAX, nós empurramos esses dados do front-end para o back-end da aplicação de modo a controlar inclusive o retorno desse processamento.

--------------

Atualmente, existem muitos FrameWorks JavaScript, como por exemplo, Angular, ReactJS e VueJS que implementam um conceito em alta, que é o conceito de SINGLE PAGES APLICATIONS( aplicações de páginas únicas) que utilizam muito, esse tipo de comunicação entre Front-end e back-end.

DIFERENÇA ENTRE O MODELO TRADICIONAL DE UMA APLICAÇÃO WEB E METODOLOGIA AJAX

	MODELO TRADICIONAL

		Durante uma requisição do cliente feito para o servidor, o Browser fica travado, porque ele está aguardando uma resposta, o servidor recebe essa requisição, faz todo processamento que é necessário e na sequência fornece uma resposta, quando a resposta chega ao navegador, o navegador trata de dar sequência ao processamento, liberando a página novamente para o usuário. Esse tempo pode demorar alguns milisegundos, e ser imperceptível para o usuário final, como também pode demorar 2, 10, 20 segundos para ser realizado, e aí sim, consegue ser realizado, o usuário final percebe que durante a execução de algum processo, ele não consegue seguir utilizando a aplicação, ele fica travado, ele precisa esperar, muitas vezes ele até interrompe o processamento, perdendo portanto a resposta daquela requisição, e isso tudo, gera custo e processamento de memória dos dois lados, tanto no FRONT quanto no Back.

	METODOLOGIA AJAX

		A própria aplicação, através de um evento no front-end, realiza uma requisição para o servidor, isso é feito através de um objeto XMLHTTPRequest, esse objeto gerencia todo o processo de envio da requisição e captura da resposta, durante esse período, que pode demorar alguns milisegundos ou vários segundos, a aplicação Web não fica travada, o usuário após disparar uma ação na aplicação, pode tranquilamente utilizar a aplicação Web, quando a resposta estiver pronta, ou seja, quando ela retornar do servidor, nós temos condições, de através do JavaScript, manipulando os elementos da página Web, através da API do DOM, recuperar essa resposta e exibir essa resposta para o usuário final. Esse tipo de metodologia de programação torna para o usuário final, mais amigável

							AULA: O QUE SÃO REQUISIÇÕES SÍNCRONAS E ASSÍNCRONAS

Se você se lembra bem, aplicações web, estão inseridas em ambiente cliente-servidor, ou seja, estamos trabalhando com requisições de páginas dinâmicas, que são entregues por um servidor a um cliente.

os métodos de trabalho síncronas e assícrona, basicamente definem o comportamento dessas requisições de respostas.

REQUISIÇÕES SÍNCRONAS

	No método síncrono, quando efetuamos uma requisição, o browser responsável por essa requisição ficará aguardando até que o servidor envie uma resposta. Ou seja, cada requisição deve ser primeiro finalizada, para possibilitar que aí sim, uma nova requisição para o servidor seja efetuada.

REQUISIÇÕES ASSÍNCRONAS

	No método assíncrono, o browser é capaz de dispara diversas requisições sem necessariamente que haja um sincronismo entre essas requisições, logo, é possível efetuar diversas requisições de forma paralela, sendo que a resposta para cada requisição será capturada pelo browser tão logo, ela seja encaminhada para o servidor.


							AULA: REQUISIÇÕES SÍNCRONAS

Antes de partir para as requisições assíncronas disponível e implementadas em todos os navegadores modernos, precisamos conhecer no detalhe como as requisições síncronas funcionam.

Através do browser, nós podemos fazer requisições síncronas para cada uma dessas páginas, ao requisitar uma página, o que acontece, é que através da internet, nós estamos fazendo uma requisição dessa página para o nosso servidor http,  e claro, essas requiisições podem ser feitas através de links.

Durante o processo de requisição, o browser sofre uma atualização, um refresh, como as páginas estão em um servidor local, esse processo é muito rápido, é quase imperceptível, mas durante esse período, ele fica travado, aguardando o retorno dessa requisição e esse comportamento de aguardar a resposta da requisição antes de fornecer para o usuário, a possibilidade de continuar utilizando a aplicação, é que nós chamamos de requisições síncronas.


						AULA: REQUISIÇÕES ASSÍNCRONAS PARTE 1 - EFETUANDO REQUISIÇÕES HTTP VIA XMLHTTPREQUEST

O objeto XMLHttpRequest é uma objeto no qual fazemos requisições para o servidor de forma assíncrona

O objeto XMLHttpRequest pode ser acessado através da linguágem de programação JavaScript. Então é o JavaScript quem vai nos permitir programar, acessar e controlar esse objeto dentro do Front-End da aplicação.

Nesse momento, é importante ter em mente que no modelo de requisições assíncronas, a estrutura do projeto muda um pouco. Agora, nós precisaremos pensar de uma forma diferente da forma tradicional de requisições síncronas. Basicamente falando, ao invés de nós ficar navegando entre páginas distintas, como no exemplo atual, nós teremos uma única página que será responsável por requisitar apenas o conteúdo dinâmico. Essa implementação, você notará, que não irá mais fazer com que a nossa página sofra um refresh a cada solicitação de dados, porque nós não iremos mais navegar de uma página para outra, mas sim, através do XMLHttpRequest, nós vamos solicitar dados ao servidor, internamente, pela própria página, fazendo com que a aplicação gerencie todo o processo de requisição e resposta, e isso fará com que a aplicação web fique muito semelhante a uma aplicação desktop. Além disso, como a própria aplicação irá gerenciar todo o processo de requisição e resposta, a aplicação se manterá disponível para o usuário final, para que ele realize novas tarefas, mesmo que uma requisição de dados, ou várias requisições de dados estejam em curso, entre o cliente e o servidor, porque o nosso XMLHttpRequest, estará gerenciando isso, de modo que cada uma dessas requisições forem retornadas pelo servidor, ou seja, logo quando as respostas forem recuperadas, nós podemos, através desse gerenciamento, tratar essas respostas e afetar a página de alguma forma.


CÓDIGO SCRIPT

<script>
	
	let ajax = new XMLHttpRequest();
	// criando objeto XMLHttpRequest.
	
	ajax.open('GET', 'pagina_1_conteudo.html')
	// O método open() é responsável por configurar qual que é a URL que será requisitada.
	// Além disso, nós podemos configurar também qual que será o método utilizado nesse processo. No caso, utilizamos o método GET.
	// Simplesmente, configurar qual que é a URL que queremos acessar, não resolve o problema. Nós precisamos de fato, enviar essa requisição.
	// Precisamos disparar o request para o servidor, para que o nosso objeto XMLHttpRequest consiga gerenciar essa resposta.

	ajax.send()
	// disparando o request para o servidor.

	console.log(ajax)

</script>

Se olharmos os atributos do método XMLHttpRequest em inspecionando a página, mais especificamente em Console, podemos ver o atributo response, que é muito importante, pois com ele é possível ver que a requisição de fato foi feita, e nós obtivemos o conteúdo contido no script pagina_1_conteudo.html que é o script que foi requisitado via XMLHttpRequest, nesse momento, ainda não estamos recuperando esse atributo e utilizando esse atributo na página. Mas é importante notar que a requisição de fato foi realizada. E sobretudo, realizado internamente sobre a aplicação.

O script que desenvolvemos nessa aula, vamos associar essa lógica aos eventos dos cliques de cada um dos botões.

Embora a aplicação estejam sendo feitas e as repostas estejam sendo recebidas, a aplicação não está navegando de uma página para a outra, e isso, do ponto de vista de usabilidade, abre muitas portas para nós. Claro, nós aprendemos a fazer essas requisições mas a partir de agora, vamos aprender a como receber essas respostas e tratar essas respostas afetando se necessário a nossa página.


						AULA: REQUISIÇÕES ASSÍNCRONAS PARTE 2 - ESTADOS DA REQUISIÇÃO


ReadyState
	- 0: request not initialized (requisição não iniciada)

	- 1: server connecttion established (conexão estabelecida com servidor)

	- 2: request received (requisição recebida)

	- 3: processing request (processando requisição)

	- 4: request finished and response is ready (requisição finalizada)

Nessa aula vamos aprender a como podemos controlar os estados de cada uma das requisições controladas pelo objeto XMLHttpRequest. 

Um detalhe importante, é que dentro do XMLHttpRequest existem dois atributos que se confundem bastante, que é o atributo State, que é justamente o que nós vamos estudar nessa aula, e o atributo Status, embora State e Status pareçam coisas semelhantes, são na verdade, atributos do objeto XMLHttpRequest que controlam informações muito diferentes, então muita atenção com o que estamos estudando nessa aula, que são os estados de cada requisição.

Ocorre que cada requisição feita a partir do objeto XMLHttpRequest passam por 5 estados diferentes, esses estados vão de 0 a 4, começando por uma requisição não incializada, na sequência, uma conexão estabelecida com o servidor, que é o estado 1, na sequência uma requisição recebida pelo servidor, que é o estado 2, entre o tempo de recebimento, e o tempo da resposta, existe o estado 3, que é o estado em que a requisição está sendo processada pelo servidor, e aí sim, o servidor envia essa resposta para o cliente, e por fim, quando o cliente recebe essa resposta, nós temos o estado 4 que é a requisição finalizada. Uma vez tendo a resposta da nossa requisição no cliente, nós podemos atrvés do JavaScript manipular essa resposta e afetar visualmente a nossa página.

Vamos ver como isso funciona na prática.

STATE 0

let ajax = new XMLHttpRequest();

//requisição não iniciada, state = 0
console.log(ajax.readyState);

	// Quando clicarmos em um botão na página e acessarmos em inspecionar página, o estado será 0 porque nenhuma requisição foi iniciada até então.

STATE 1

// podemos agora estabelecer um conexão com o servidor.
ajax.open('GET', url);

	// O método open() indica qual que é o verbo e qual que é a URL que vamos utilizar para abrir uma conexão com algum servidor. Lembrando que pode ser qualquer servidor capaz de responder requisições http, é dessa forma por exemplo, que nós podemos consumir recursos de API's, nós vamos flar de APIs mais adiante, mas já fica a dica.

	// Uma vez estabelecida com o nosso servidor, através do método Open(), nós vamos ver que o nosso readyState (estado do objeto ajax) vai evolur para a conexão estabelecida com o servidor.

// conexão estabelecida com o servidor, state = 1
console.log(ajax.readyState);


----------------

Agora nós temos pela frente outros três estados, porém eles são mais complexos de serem tratados, isso porque o primeiro estado, que é o 0, e o segundo estado, que é o estado 1, são os estados em que nós na condição de programadores estamos disparando os seus respectivos eventos, ou seja, a criação do objeto e a conexão com o servidor quem estabelece é a aplicação, porém agora, os demais estados são na verdade, notificados pelo servidor para o cliente, ou seja, o cliente precisa estar configurado para ficar ouvindo esses eventos do servidor, logo, quem starta o progresso do estado da requisição, não é mais o cliente e sim, a aplicação servidora. Para ficar ouvindo essa mudança de estado uma vez que a requisição foi disparada - e para fazer isso, nós utilizamos o método send() - nós precisamos de alguma lógica que fique olhando para o progresso da requisição. Para fazer isso, precisamos de um método do objeto XMLHttpRequest que é o método onreadystatechange(), esse método é disparado, sempre quando o estado do objeto ajax é modificado, inclusive, quando essa modificação é proveniente do servidor. O estado 2 ele ocorre quando o servidor recebe a requisição disparada, enviada pelo Cliente, quando o servidor recebe essa requisição, ele automaticamente notifica o cliente de que ele recebeu uma requisição, repare que não se trata da respost da requisição (não é um Resposnse) é na verdade um RefirewallRequest, ou seja, o serviddor apenas notifica o cliente de que recebeu a requisição, e então o cliente fica aguardando o seu processamento, e posteriormente a sua resposta.


function requisitarPagina(url){
	let ajax = new XMLHttpRequest();

	console.log(ajax.readyState);

	ajax.open('GET', url)

	console.log(ajax.readyState)

	// de alguma lógica que fique olhando par o progresso da requisição
	ajax.onreadystatechange() = function() {
		console.log(ajax.readyState)
	}


	ajax.Send()
}


onreadystatechange() recebe uma função que acaba se tornando um método

Na prática, geralmente, nós utilizamos apenas o estado 4, isso porque, o estado 4, indica que a requisição foi finalizada, e através de uma requisição finalizada, nós podemos recuperar a resposta fornecida pelo servidor, e tomar alguma ação, vale lembrar porém que, não necessariamente, significa que essa requisição foi finalizada com a resposta desejada, pode ser que a requisição tenha sido feita com sucesso para o serviddor http funcional, porém solicitando um recurso inexistente, então o servidor informa a inexistência do recurso solicitado e o estado continu sendo 4, ou seja, indicando que a requisição foi finalizada com sucesso, mas não necessariamente a resposta é a resposta que queremos, é aí que nós podemos combinar o estado com o status da requisição.


						AULA: REQUISIÇÕES ASSÍNCRONAS PARTE 3 - APLICANDO UM LOADING

Agora que nós já sabemos como nós podemos usar o objeto XMLHttpRequestpara realizar requisições para servidores http, e sobretudo, já sabemos sobretudo, a como controlar o estado da requisição, nessa aula, nós vamos apenas aplicar um feedback visual para o usuário final, enquanto o processo de requisição estiver em curso, nós faremos isso, através da apresentação de um gif de loading. Para fazer isso, nós vamos utilizar basicamente o JavaScript, nós vamos manipular a página web a partir da API do DOM, e de forma bem simples, nós vamos conseguir obter esse resultado a partir de duas atividades:

1) No disparo da requisição apresentar o gif de loading

2) Ao atingir o estado 4 da requisição remover o gif de loading

						AULA: REQUISIÇÕES ASSÍNCRONAS PARTE 4 - STATUS DA REQUISIÇÃO

A requisição XMLHttpRequest desde o processo do envio de uma Request, até o seu respectivo processamento do servidor, e posterior resposta do servidor para o cliente, possui diversos estados, porém, a resposta dessa requisição pode possui diversos Status diferentes. Portanto, os status de uma requisição não estão relacionados com o estado da mesma.

Não necessariamente os status podem visíveis por meio do objeto XMLHttpRequest, eles estão atrelados à qualquer tip de requisição feita na internet para um servidor.

Diferentes status:

1 - Respostas de informação (100-199),
2 - Respostas de sucesso (200-299),
3 - Redirecionamentos (300-399)
4 - Erros do cliente (400-499)
5 - Erros do servidor (500-599).

Nessa aula vamos focar nos status 200 que diz respeito sobre respostas de sucesso e os status 404 que se encontra no grupo de erros do cliente.

Status 200

	É o Status que indica que  requisição foi bem-sucedida.

Status 404

	É o Status no grupo de erros do cliente, que indica que o cliente solicitou um recurso que não existe no servidor.


// appendChild - Adiciona um nó filho ao elemento pai

// innerHTML -Atualiza o conteúdo interno de um elemento

						AULA: REQUISIÇÕES ASSÍNCRONAS PARTE 5 - RESPONSE TEXT

Chegou a hora de descobrir de receber a resposta de uma requisição, trabalhar com essa respectiva resposta e apresentar um conteúdo dinâmico na página.

Para fazer isso basta trabalhar com o atributo ResponseText.

Response Text só preencherá com as informações necessárias depois que o status da requisição for 200, ou seja, a requisição for bem-sucedida.

						AULA: XML O QUE É? PARTE 1

XML Significa eXtensible Markup Language

XML é um linguagem de marcação assim como o HTML

A linguagem de marcação XML porém, serve para estruturar e descrever informações, basicamente falando, o XML é um recurso para comunicação entre sistemas distintos, trocas de informações que podem ser feitas entre qualquer tipos de sistemas.

POSSIBILIDADES:

	Um frontEnd da aplicação  pode requisitar um documento XML de um servidor http, ou um servidor http pode requisitar um arquivo XML diretamente de outro servidor http.

É necessário um padrão, regras de comunicação necessárias para que trocas de informações sejam efetivas entre diferentes sistemas, ou seja, tais regras precisam ser respeitadas para que a comunicação entre as pontas sejam efetivas.

O XML é a base para a construção de APIs que seguem o padrão SOAP, porém, esse modelo de comunicação utilizando XML está caindo em desuso.

						AULA: XML PARTE 2 - RECUPERANDO ARQUIVO XML DO SERVIDOR VIA HTTP

Nessa aula vamos criar uma página web que apresente uma relação de filmes, a diferença dessa página web para uma página web tradicional, é que a relação de filmes será incluida nessa página através de uma requisição de um arquivo XML que esteja disponível no servidor. Repare que nós não iremos formar uma página web dinâmica, onde a relação de filmes já esteja presente, vamos requisitar através do XMLHttpRequest a página web filmes.html, e a partir dela, vamos requisitar novamente com o XMLHttpRequest requisitar o arquivo filmes.xml que contém a relação de filmes, ao receber essa resposta com a relação de filmes, nós vamos manipular o dom inserindo cada um desses filmes nessa página.

Então perceba que, essa aplicação irá transicionar apenas dados. Uma vez a aplicação no browser, a comunicação com o servidor será apenas por recuperar dados, através de arquivos XML e não páginas web-dinâmicas.

Todo arquivo XML começa com a tag <?xml version="1.0" encoding="UTF-8" ?>
Onde a versão é obrigatória.
O Encoding é opcional.


						AULA: CONVERTENDO XML PARA JSON E PORQUÊ

O XML não é nativamente suportado pelo JavaScript, diferente por exemplo do JSON, além disso, a requisição que estamos fazendo, retorna para nós uma string.

Os dados que são trafegados entre cliente e servidor são basicamente textos , por isso que esses textos precisam de marcações, para que, associados a esses textos, sseja possível a incluir metadados, a marcação título é o que define que o que está dentro dela seja um título, e não apenas um texto puro. O encapsulamento em tags é na verdade uma forma de associar metadados a textos puros, é assim que podemos diferenciar um caso de string do outro.

A notação JSON também trafega em texto, ou seja, não possui objetos instanciados sendo trafegados em requisições http, porém, diferente do XML, o JSON é nativamente suportado pelo JavaScript, nesse caso, como estamos trabalhando com XML, nós precisamos fazer esse parse, para que seja possível manipular essas informações que atualmente estão dispostas em um texto puro, a partir desse texto puro, fica difícil fazer qualquer tratativa em cima dessas informações. Então nós vamos transformar tudo isso num objeto, para aí sim, percorrer esse objeto, e manipular as suas respectivas informações, ocorre porém, que nós estmos trabalhando com JavaScript puro, fazer isso na mão é razoavelmente complexo, existem bibliotecas que nos ajudam a desenvolver isso de forma muito prática, o Jquery é uma dessas bibliotecas, através do Jquery é muito mais fácil manipular arquivos XML, mas nós ainda não estamos trabalhando com elee, então nesse primeiro momento, nós vamos fazer isso da forma difícil.

PARSE DE XML PARA JSON

	Precisamos converter esse texto puro, em uma árvore de elementos, análogo ao próprio DOM. Podemos fazer esse tipo de implementação pela classe nativa JavaScript chamada de DOMParser

	let XMLFilmes = xmlHttp.responseText

                let parser = new DOMParser()

                XMLFilmes = parser.parseFromString(XMLFilmes, 'text/xml')
	// Esse método espera dois parâmetros, o primeiro é a string que eu quero fazer o parser, o segundo indica qual é a notação utilizada para notação dessa string, para que o domparser saiba como converter essa string numa árvore de elementos.

	Tendo a árvore de elementos em mãos, podemos utilizar o JavaScript para fazer o parser dessa árvore para um objeto JSON(não esqueça de baixar o documento .js da aula)


						AULA: REFACTORING DA COMUNICAÇÃO COM O BACK-END UTILIZANDO JSON

Em aulas anteriores vimos que a notação XML nos permite estruturar informações para a comunicação entre aplicações distintas. Porém vimos também que o XML não é nativamente suportado como um tipo de dado dentro do front-End de aplicações Web e quando estamos trabalhando com o JavaScript é necessário fazer uma conversão de tipos para transformar essa anotação em um objeto e com isso fazer a manipulação das informações afetando os elementos HTML da página.


Nessa aula nós vamos fazer um efeito desse processo de comunicação substituindo o XML por um JSON. A ideia é demonstrar como que nós podemos  trabalhar com essa anotação, a notação de JSON para comunicação entre aplicações distintas tendo aqui um benefício que é o fato de que arquivos json ou melhor na anotação json é nativamente suportada por aplicações Web front end

Como trabalhar com JSON é muito mais fácil do que se trabalhar com a notação XML, a APIs RESTFul que é baseada em JSON vem ganhando muito mais espaço do que as APIs baseada em XML, 

RESTFul - Baseada em JSON

SOAP - Baseada em XML

A diferença mais importante entre essas duas notações é que o JSON é suportado nativamente como um objeto dentro da aplicação.


						SECTION 15: PHP COM PDO E MYSQL

						AULA: INTRODUÇÃO AO PDO

PDO - PHP Data Objects

Para que serve o PDO?

Qual a vantagem de se trabalhar com PDO?

// O PDO consiste em um conjunto de objetos que nos auxiliam no trabalho com bancos de dados. O objetivo do PDO é prover uma padronização da forma com que o PHP se comunica com os bancos de dados. Na prática esses objetos são agregados ao PHP no formato de extensão. Portanto tais objetos podem ser habilitados ou desabilitados através do arquivo PHP.INI conforme é claro a nossa necessidade.


						AULA: CRIANDO UMA CONEXÃO ENTRE O PDO E MYSQL COM PDO


Para criar uma instância de PDO nós precisamos passar alguns parâmetros para configurar a nossa conexão, o primeiro parãmetro é conhecido como o parãmetro Data Source Name (DSN), que nada mais é do que o nome da fonte de dados, porque é ele quem vai dizer qual que é o drive de conexão que vai ser utilizado ( tal driver pode ser consultado em php.ini ), começamos pelo prefixo, seguindo do host que nesse caso é localhost, se fosse em outra máquina, utilizariamos o endereço de IP ou a URL, ainda na DNS, precisamos informar qual que é o banco de dados naquele host que vamos acessar, utilizamos as siglas dbname=<nome_banco_dados>. O segundo parâmetro é o usuário do banco de dados. O terceiro parâmetro é a senha.

Primeiro parâmetro

	DSN - Passamos o nome do SGBD, o host (podendo ser local ou externo), o nome do banco de dados dentro do SGBD.

Segundo parãmetro

	Usuário do banco de dados

Terceiro parâmetro

	Senha.

EXEMPLO:

	$conexao = new PDO('mysql:host=localhost;dbname=php_com_pdo', 'root', '')


						AULA: TRATANDO EXCCEPTIONS (PDOEXCEPTION)

Sempre quando o PDO identifica um erro, o PDO trata esse erro e produz um exceção, que é a PDOException, e através ddela, podemos tratar esse erro de forma reativa. Assim, ao invés da aplicação quebrar, podemos tratar isso como uma espécie de contorno. 

Pense PDOException como sendo um objeto dentro de PDO que será populado com informações do erro. Então, ocorrendo um erro, haverá dentro de PDO, um Throw que vai disparar o PDOException, esse objeto que pode ser manipulado dentro do nosso script.

Podemos também utilizar a captura de exceções do objeto PDOException para registrar essa exceção, de modo que posteriormente os programadores possam trabalhar para analisar o motivo desse erro, e tentar corrigir ou evitar.


						AULA: EXECUTANDO INSTRUÇÕES SQL (EXEC)

Nessa aula nós vamos aprender a como podemos realizar instruções SQL utilizando o EXEC.

Agora que nós já estamos conseguindo fazer uma conexão com o banco de dados (php_com_pdo), a partir de instruções SQL (query), nós podemos realizar a criação de uma tabela dentro do nosso banco de dados. E nós podemos fazer isso, justamente usando o método EXEC do PDO, que é um pouco limitado, mas vamos por partes.

PASSOS:

	Primeiro nós precisamos montar a query que queremos executar.

exemplo

	$query = '
		create table if not exists tb_usuarios(
                			id int not null primary key auto_increment
                			nome varchar(50) not null,
                			email varchar(100) not null,
                			senha varchar(32) not null
         		)
	';

	$conexao->exec($query)

	Substitua o trecho do comando "create table tb_usuarios" por: create table if not exists tb_usuarios. Dessa forma, em futuras execuções do script, caso a tabela já exista no banco de dados, então não hverá uma tentativa de recriá-la, evitando portanto o erro de tbela já existente no banco (already exists)

	Assim, basta enviar essa query por parâmetro, e o PDO trata  de processar essa informação junto ao banco que estamos estabelecendo na nossa conexão. 

	Um detalhe importante, o método exec do PDO, retorna apenas o número de linhas que foram ou modificadas, ou removidas pela instrução SQL que estamos encaminhando, então quando nós estamos trabalhando por exemplo, com o querys, DDL(data defition language), ou seja, instruções que vão definir a estrutura dos dados, nós teremos sempre o retorno de 0. Isso porque, nesse processo de definição dos dados em que estamos criando as estruturas para receber os dados, nós não estamos de fato afetando/modificando ou removendo esses dados, por isso o retorno esperado é 0. Um SELECT que faz parte do conjunto da subcategoria DML (data manipulation language) também retornaria 0, porque o select não está nem modificando, nem removendo registros. Já instruções como UPDATE, DELETE e INSERT, iriam retornar para nós a quantidade de linhas afetadas no processo, portanto, perceba que o retorno do exec é bastante limitado, para as operações de CRUD, nós não iremos utilizar o exec, mas é importante conhecê-lo, porque a partir dele, é possível executar qualquer tipo de query dentro do banco de dados.

	C - Create (criar)
	R - Read (ler)
	U - Udate (atualizar)
	D - (deletar)

CÓDIGO DE AULA:

$dsn = 'mysql:host=localhost:3312;dbname=php_com_pdo';
$usuario = 'root';
$senha = '';

try{

       $conexao = new PDO($dsn, $usuario, $senha);
        $query = '
            create table if not exists tb_usuarios(
                id int not null primary key auto_increment,
                nome varchar(50) not null,
                email varchar(100) not null,
                senha varchar(32) not null
            )
        ';

        $retorno = $conexao->exec($query);
        //0
        echo $retorno;
}catch (PDOException $e){
        echo 'Erro: ' . $e->getCode() . ' Messagem: ' . $e->getMessage();
        //registrar erro
}


							AULA: PDOSTATEMENT OBJECT (QUERY) COM FETCHALL

Nessa aula vamos entender como podemos utilizar o método query do PDO para enviar do PHP para o PDO, instruções SQL, de modo que o PDO nos retorne um PDOStatement Object, ou seja, um objeto, que contenha a declaração da nossa query, e que nos permita recuperar as informações contidas no banco de dados.

EXEMPLO:

	$conexao = new PDO($dsn, $usuario, $senha);
        
        	$query = '
            	select * from tb_usuarios
        	';

        	$stmt = $conexao->query($query);
        	print_r($stmt);

se formos ver no navegador aparece:

PDOStatement Object ( [queryString] => select * from tb_usuarios )

	Ous seja, contém apenas a nossa instrução SQL.

CÓDIGO DE AULA:

	$conexao = new PDO($dsn, $usuario, $senha);
        
       	 $query = '
       	 select * from tb_usuarios
       	 ';

        	$stmt = $conexao->query($query);
        	$lista = $stmt->fetchAll()

// O método fetchAll() retorna para nós todos os registros recuperados da consulta, nós podemos portanto, atribuir esse retorno numa variável.


							AULA: FETCH ALL - TRABALHANDO OS TIPOS DE RETORNOS

Nessa aula, o nosso objetivo é bem simples, nós vamos apenas aprender a como nós podemos manipular o retorno dado pelo FetchAll() a partir da passagem de um parâmetro para esse método.

Para trazer apenas os registros de forma associativa, ou seja, com os nomes das colunas sendo os seus respectivos índices,  nós podemos passar por parâmetro a instrução PDO::FETCH_ASSOC

	$stmt = $conexao->query($query);
	$lista = $stmt ->fetchAll(PDO::FETCH_ASSOC);

	FECTH_NUM pega os índices numéricos.

Podemos também não mais trabalhar com array de arrays, mas sim, array de objetos. Para fazer isso nos basta:

	$stmt->fetchAll(PDO::OBJ)

	Com isso, teremos objetos baseados na classe stdClass, repare que conforme o retorno muda, nós precisamos modificar também a forma como recuperamos os valores. Ficaria assim:

	echo '<br>';

        	echo $lista[0]->nome;

        	echo '<br>';

Existem outras opções de retorno também, embora seja menos utilizadas, porém, é possível entendê-las através da documentação do php especificamente em pdo.


							AULA: RETORNANDO APENS UM REGISTRO

Nessa aula iremos usar outro método, o método Fetch. Diferente do método FetchAll(), o Fecth() recupera apenas um único registro, e isso não faz muito sentido quando estamos realizando consultas de diversos registros ao mesmo tempo, porém, existem situações, onde nós iremos selecionar apenas um único registro, por exemplo, digamos que nesse caso, eu queira selecionar apenas o registro de id 6, então na instrução SQL feita por meio da variavel query, utilizamos o filtro WHERE para que selecionamos apenas o que desejamos. Repare que nós iremos recuperar apenas um único registro, 

        	$conexao = new PDO($dsn, $usuario, $senha);
        
        	$query = '
            	select * from tb_usuarios where id = 6
        	';

        	$stmt = $conexao->query($query);
        	$usuario = $stmt->fetch(PDO::FETCH_OBJ);

        	echo '<pre>';
        	print_r($usuario);
        	echo '</pre>';

	echo $usuario->nome

// É importante ter em mente que o método fetch, como ele pega apenas um registro, nós temos que apresentar as informações diferente do modo em que apresentamos com FetchAll()


							AULA: LISTANDO REGISTROS COM FOREACH


Nessa aula nós vamos aprender a como podemos manipular esses registros utilizando o foreach, percorrendo cada uma dessas informações e fazendo a impressão no navegador de acordo com a nossa necessidade. Ou seja, saindo do debug básico do print_r().

CÓDIGO DE AULA:

try{

        $conexao = new PDO($dsn, $usuario, $senha);
        
        $query = '
            select * from tb_usuarios
        ';

        $stmt = $conexao->query($query);
        $lista_usuarios = $stmt->fetchAll(PDO::FETCH_ASSOC);

        /*
        echo '<pre>';
        print_r($lista_usuarios);
        echo '</pre>';
        */

        foreach($lista_usuarios as $key => $value){
            print_r($value['nome']);
            echo '<hr>';
        }

}

impressão na tela:

Lucas Lima
Gustavo Lima
Josy Lima

// Repare que com o foreach podemos fazer as listagens desses registros bem mais acessíveis.

Existe uma outras técnica de listar os valores de uma consulta através de um foreach, que é utilizando uma técnica conhecida como Query On The Run, ou seja, recuperando cada um dos seus registros, no instante da execução do método query.

EXEMPLO:


        $conexao = new PDO($dsn, $usuario, $senha);
        
        $query = '
            select * from tb_usuarios
        ';
        
        foreach($conexao->query($query) as $key => $value){
            print_r($value['nome']);
            echo '<hr>';
        }

impressão na tela:

Lucas Lima
Gustavo Lima
Josy Lima
	

							AULA: SQL INJECTION

Nessa aula nós vamos falar sobre SQL INJECTION que é uma grande vulnerabilidade, quando as nossas aplicações não tratam devidamente, as instruções SQL que são submetidas para o SGBD, Sql Injection é literalmente, a injeção de instruções SQL, seja na url ou no corpo do request, de informações que serão utilizadas que serão utilizadas para compor as nossas querys, do lado do Back-End, para entender isso melhor, vamos criar uma aplicação sucetível às instruções SQL, e vamos ver os resultados disso.

FRONT-END

	Criamos um formulário simples direcionando nossas informações contidas nos inputs para a própria ppágina index.php

PHP

<?php

    if(!empty($_POST['usuario']) && !empty($_POST['senha'])){
        $dsn = 'mysql:host=localhost:3312;dbname=php_com_pdo';
        $usuario = 'root';
        $senha = '';

        try{

            $conexao = new PDO($dsn, $usuario, $senha);

            $query = "select * from tb_usuarios where ";
            $query .= "email = '{$_POST['usuario']}' ";
            $query .= " AND senha = '{$_POST['senha']}'";

            echo $query;

            $stmt = $conexao->query($query);
            $usuario = $stmt->fetch();
            
            echo '<pre>';
            print_r($usuario);
            echo '</pre>';

        }catch(PDOException $e){
            echo 'Erro: ' . $e->getCode() . ' Messagem: ' . $e->getMessage();
            
        }
    }

?>

	// Perceba que na variável $query onde definimos nossas instruções SQL, podemos colocar as nossas variáveis php abrindo e fechando chaves como fazemos parecido nas tags de impressão do php.


E o que o SQL Injection tem haver com tudo isso que nós fizemos?
	
	O SQL Injection é uma vulnerabilidade da nossa aplicação quando do back-end, as instruções do SQL não são previamente tratadas. Imagine que uma pessoa má intencionada insira muito mais do que apenas as informações, insira também, instruções SQL, que quando submetidas para o Back-End serão processadas, isso terá um resultado se essa instrução SQL for correta, e normalmente, esse resultado é muito negativo.

O PDO é uma biblioteca qque vai nos ajudar a enfrentar esse problema, evitar que instruções SQL injetadas seja na url, ou no body do request, sejam processadas pelos nossos scripts de forma indevida.


							AULA: PREPARE STATEMENT


Na aula anterior, vimos o quão perigoso é, manter as nossas aplicações vulneráveis à injeções SQL

Nessa aula, nós vamos aprender a como podemos contornar essa vulnerabilidade, a como podemos tornar as nossas aplicações bem mais seguras nesse aspecto. Para fazer isso, nós utilizamos uma função do PDO que é a função PREPARE, ao invés de nós simplesmente executar uma query, nós vamos preparar um Statement. Ou seja, vamos executar o método prepare, que continua retornando para nós um PDOStatement, porém nós podemos antes da execução do nosso Statement (da nossa declaração) fazer algumas tratativas nos parâmetros que irão compor as nossas querys.

CRIAMOS OS REGISTROS

<?php

    //if(!empty($_POST['usuario']) && !empty($_POST['senha'])){
        $dsn = 'mysql:host=localhost:3312;dbname=php_com_pdo';
        $usuario = 'root';
        $senha = '';

        try{

            $conexao = new PDO($dsn, $usuario, $senha);

            $query = "insert into tb_usuarios(nome, email, senha) values
                ('Lucas Lima de Souza', 'lucas@gmail.com', '123456')";
            $conexao->query($query);

            $query = "insert into tb_usuarios(nome, email, senha) values
                ('Gustavo Lima de Souza', 'gustavo@gmail.com', '123456')";
            $conexao->query($query);

            $query = "insert into tb_usuarios(nome, email, senha) values
                ('Josivani Lima de Moura', 'Josy@gmail.com', '123456')";
            $conexao->query($query);

        }catch(PDOException $e){
            echo 'Erro: ' . $e->getCode() . ' Messagem: ' . $e->getMessage();
            
        }
    //}

?>

// Comentamos a estrutura condicional pois queremos criar os registros sem que outros registros precisam estar instanciados.

E DEPOIS UMA QUERY DE CONSULTA:

// Tal consulta é igual ao que fizemos na aula anterior, e como vimos, está vulnerável a SQL Injection.

?php

    if(!empty($_POST['usuario']) && !empty($_POST['senha'])){
        $dsn = 'mysql:host=localhost:3312;dbname=php_com_pdo';
        $usuario = 'root';
        $senha = '';

        try{

            $conexao = new PDO($dsn, $usuario, $senha);

            $query = "select * from tb_usuarios where ";
            $query .= "email =  :usuario ";
            $query .= "AND senha = '{$_POST['senha']}'";

            $stmt = $conexao->prepare($query);

            $stmt->bindValue(':usuario', $_POST['usuario']);
            $stmt->bindValue(':senha', $_POST['senha']);
            $stmt->execute();

        }catch(PDOException $e){
            echo 'Erro: ' . $e->getCode() . ' Messagem: ' . $e->getMessage();
            
        }
    }

?>

// Dessa forma, nós estávamos montando querys sujeitas à injeção de SQL. Para resolver esse problema, nós vamos a partir da instância do nosso objeto PDO. Executar agora o método prepare, que retorna para nós um PDOStatement. A diferença é que o prepare não executa a query diretamente, ele fica aguardando que você dê essa ordem de execução. Por que? Por que antes nós vamos de fato preparar a nossa query, e nós vamos fazer isso através do método Bind Value do objeto Statement, que é retornado pelo método prepare. Exemplo:

		$stmt = $conexao->prepare($query);

		$stmt->bindValue(':usuario', $_POST['usuario']);
		// O primeiro parâmetro é uma variável de ligação, o Bind. O segundo parâmetro é valor de fato dessa ligação.
		// O valor recebido do email será submetido para BindValue() do objeto Statement, onde haverá uma ligação. Após esse respectivo valor ser tratado internamente pelo método Bind, removendo qualquer injeção de SQL será ligado à uma variável que será establecida na $query, essa variável nós vamos definir como send :usuario no primeiro parâmetro, ou seja, o nome dessa variável é a nossa ligação.
		// Feito isso, basta executar a nossa query pelo método do Statement chamado execute().

DETALHE IMPORTANTE:

	Por padrão, todo o valor do segundo parâmetro do método binValue é interpretado como uma string.

	A função bindValue() pode trabalhar com um terceiro parâmetro, que é o tipo de dado dentro do parãmetro que estamos informando que deve ser considerado caso haja um SQL Injection, ou seja, sei como fazer uma análise do valor contido dentro desse segundo parâmetro : $stmt->bindValue(':usuario', $_POST['usuario']) mesmo que esse parâmetro contenha injeções de SQL de valores que poderiam de fato ser utilizados na consulta.

	PDO::PARAM_INT é um dos seus valores, em conjunto de caracteres, ele encontrará o inteiro e irá apenas considerar esse tipo de dado.


							AULA: APP LISTA DE TAREFAS - INICIANDO O PROJETO

O mais importante dessa aula, foi a criação das tabelas que a aplicação vai possuir, por isso, achei importante anotar, a tabela tb_tarefas terá uma chave de referência da tabela tb_status. Segue o código:

create table tb_status(
     id int not null primary key auto_increment,
    status varchar(25) not null
);

insert into tb_status(status)values('pendente');
insert into tb_status(status)values('realizado');

create table tb_tarefas(
	id int not null primary key auto_increment,
    id_status int not null default 1,
    foreign key(id_status) references tb_status(id),
	tarefa text not null,
    data_cadastrado datetime not null default current_timestamp
)

	
							AULA: APP LISTA DE TAREFAS - CRIANDO A CLASSE TAREFA

Ness aula, criamos a classe Tarefa dentro de uma pasta protegida da aplicação, para que os usuários não tenham o acesso.

Na classe criamos atributos privados com os mesmos nomes das colunas do banco de dados e para cada um desses atributos definimos um getters e setters mágicos.



							AULA: APP LISTA DE TAREFAS - CRIANDO A CLASSE TAREFASERVICE

Agora que já criamos a classe Tarefa. Nessa nós vamos trabalhar na criação da classe TarefaService().

A idéia é utilizar essa classe para a instância de um objeto que vai intermediar a gravação de uma tarefa no banco de dados.

CÓDIGO DA CLASSE:

<?php

    class TarefaService{
        public function inserir() { //create

        }

        public function recuperar() { //read

        }

        public function atualizar() { //update

        }

        public function remover() { //delete

        }
    }

?>

							AULA: APP LISTA DE TAREFAS - CRIANDO A CLASSE CONEXÃO

Nessa aula vamos criar a classe de conexão com o MySQL utilizando o PDO.



							AULA: APP LISTA DE TAREFAS - INSERINDO REGISTROS

Tarefa_controller.php é justamente o responsável por instanciar o objeto tarefa e através do TarefaService utilizando a nossa conexão, controlar a persistência dessa tarefa no nosso banco de dados. Então repare que nós temos um script importante que vai centralizar os componentes da nossa aplicação para que a gente possa, nessa aula, fazer o insert de novos registros.

Por ser tão importante  é imprescíndível que coloquemos tal arquivo na pasta protegida chamada de app_lista_tarefas. Então temos:

Diretório público (htdocs)								app_lista_tarefas
tarefa_controller.php								tarefa_controller.php
// faz o require da tarefa_controller.php na pasta protegida
			
No decorrer dessa aula, iremos precisar fazer os requires dos outros arquivos php's no tarefa_controller.php. No entanto, quando fazemos esse tipo de require, que é um require dentro de outro require ( tarefa_controller.php que faz um require dentro  da pasta app_lista_tarefa para tarefa_controller.php ) os requires seguintes ficarão no contexto do script tarefa_controller.php dentro do diretório htdocs.

Então, nós temos que ajustar essas requisições em função do contexto. Como fazemos isso? Simples, basta voltar dois níveis do caminho especificado nos requires e indicar o diretório app_lista_tarefa.

TAREFA_CONTROLLER.PHP

	Criamos a instância de tarefa

		Atribuimos ao setters a variável $_POST com índice tarefa.

	Criamos uma instância de conexão

	Criamos uma instância de tarefa Service

		Porque? Porque é o objeto TarefaService que vai recuperar o objeto de tarefa e a conexão para a realização das operações junto ao banco de dados. Por isso que estamos 			criando a instância desse objeto também

		Para começar a trabalhar com as operações de Crud nós precisamos receber o objeto que queremos persistir e a conexão. Então a nossa classe TarefaService precisa receber 		esse parâmetros e atribuir esses parâmetros à atrbutos internos.

		Ex:
		class Tarefa(){
			public function __construct(Conexao $conexao,Tarefa $tarefa){
            				$this->conexao = $conexao;
            				$this->tarefa = $tarefa;
        			}
		}

		// Nós podemos melhorar um pouco o construct. Perceba no parâmetro do método construtor que nós podemos tipar o tipo de dado está sendo recebido por parâmetro.
		// Porque são variáveis que contém objetos baseados na classe Conexao e na classe Tarefa. Então nós podemos utilizar esse recurso de tipagem, se vier outro objeto que não 			// seja baseado na classe Conexao, ou que não seja baseado na Classe Tarefa, Respectivamente, a aplicação apresentará uma mensagem de erro para nós.

	Dentro da classe TarefaService utilizamos o método conectar do objeto $conexao
		Perceba que isso é possível por causa dos requires defnidos anteriormente
		class Tarefa(){
			public function __construct(Conexao $conexao,Tarefa $tarefa){
            				$this->conexao = $conexao->conectar();
            				$this->tarefa = $tarefa;
        			}
		}

	Ainda dentro de TarefaService modificamos cada um dos métodos dessa classe.

	Depois colocar $tarefaService->inserir() para vermos o resultado.


							AULA: APP LISTA TAREFAS - INSERINDO REGISTROS (FEEDBACK)

Logo de começo aplicamos um header() no script tarefa_controller.php para direcionarmos à página de nova_tarefa.php em outro diretório, fica desse jeito:

	header("Location: nova_tarefa.php?inclusao=1");

		Com isso, você pode se perguntar porque não saímos da pasta atual, se tal script não existe nesse caminho, no caso, o path onde este se encontra?
		Novamente retomo que estamos falando de contexto, o require desse script foi adicionado num script em outro diretório, portanto, o Location passará a ser 				app_lista_tarefas_public onde foi feito o require.

Fizemos um direcionamento para a página nova_tarefa.php com um parâmetro especificado na url, tal valor pode ser obtido através do método GET.

Na nova_tarefa.php fizemos uma estrutura condicional e caso o índice inclusao esteja cetado e o seu valor seja igual a 1, mostraremos o resultado do feedback na página.

	
							AULA: APP LISTA TAREFAS - LISTANDO TODOS OS REGISTROS PARTE 1

Nessa aula vamos fazer com que a nossa aplicação se torne mis dinâmica, pegando os valores obtidos da nossa tabela tb_tarefas no banco de dados php_com_pdo e vamos inserir esses registros na nossa página todas_tarefas.php

O segredo dessa aula está no tarefa_controller.php que irá "conversar" com os scripts de diferentes diretórios. São eles:

	Diretório publico (htdocs)				app_lista_tarefas

	nova_tarefa.php					tarefa.model.php
	todas_tarefa.php					tarefa.service.php
	tarefa_controller.php				conexao.php


Esse script tarefa_controller.php irá controlar todas as regras de negócio.

PASSOS DA AULA:

	Em nova_tarefa.php adicionamos no action da form um parâmetro acao=inserir e nele vamos usar para aplicarmos a lógica ccontida em tarefa_controller.php. Fica assim:

		<form action="tarefa_controller.php?acao=inserir" method="post">

		TAREFA_CONTROLLER:

			if(isset($_GET['acao']) && $_GET == 'inserir'){


    				$tarefa = new Tarefa();

    				$tarefa->__set('tarefa', $_POST['tarefa']);

    				$conexao = new Conexao();

    				$tarefaService = new TarefaService($conexao, $tarefa);

    				$tarefaService->inserir();

    				header("Location: nova_tarefa.php?inclusao=1");

    			}

	Em todas_tarefas.php adicionamos no começo do script tags php, contendo uma variável $acao = 'recuperar' e um require 'tarefa_controller.php';

		TODAS_TAREFAS
			<?php
				$acao = 'recuperar';
				require 'tarefa_controller.php';
			?>

		// Um detalhe importante, tudo declarado antes do require, pode ser acessado e modificado pelo script que está sendo direcionado. Ou sej, faz parte do seu contexto.
		// Vamos utilizar essa variável no corpo do script tarefa_controller.php

		TAREFA_CONTROLLER

			<?php

    				require "../../app_lista_tarefa/tarefa.model.php";
   				require "../../app_lista_tarefa/tarefa.service.php";
    				require "../../app_lista_tarefa/conexao.php";

    				if(isset($_GET['acao']) && $_GET == 'inserir'){


    				$tarefa = new Tarefa();

    				$tarefa->__set('tarefa', $_POST['tarefa']);

    				$conexao = new Conexao();

    				$tarefaService = new TarefaService($conexao, $tarefa);

    				$tarefaService->inserir();

    				header("Location: nova_tarefa.php?inclusao=1");

    				}else if($acao == 'recuperar'){
        					echo 'Chegamos até aqui!';
    				}

			?>
		
			Repare que, em certo momento, ora estamos testando recebido um valor pela requisição GET, ora estamos testanto por uma variável com o valor hardcode.
			Como que nós podemos controlar a nossa aplicação de modo que ela saiba tratar ou a informação recebida por parâmetro, ou essa variável previamente 					estabelecida? Simples podemos fazer um teste, se houver um índice acao cetado na super global GET nós vamos trabalhar com esse respectivo valor, ou seja, nós 			vamos verificar o índice acao se está cetado na super globl $_GET, se sim atribuiremos o seu valor na variável $acao, caso contrário, a nossa aplicação vai esperar 			diretamente uma variável chamada $acao, e essa variável foi definida antes do require.

				$acao = isset($_GET['acao']) ? $_GET['acao'] : $acao;

				
			Então fica:

			<?php

   				require "../../app_lista_tarefa/tarefa.model.php";
   				require "../../app_lista_tarefa/tarefa.service.php";
    				require "../../app_lista_tarefa/conexao.php";

    				$acao = isset($_GET['acao']) ? $_GET['acao'] : $acao;

    				if($acao == 'inserir'){


    				$tarefa = new Tarefa();

    				$tarefa->__set('tarefa', $_POST['tarefa']);

    				$conexao = new Conexao();

    				$tarefaService = new TarefaService($conexao, $tarefa);

    				$tarefaService->inserir();

   				header("Location: nova_tarefa.php?inclusao=1");

    				}else if($acao == 'recuperar'){
        					echo 'Chegamos até aqui!';
    				}

			?>

		Tudo isso se fez necessário, ou seja, criamos esse fluxo para que a partir de algumas verificações possamos finalmente demarcar os códigos que irá manipular a quantidade e o conteúdo das respectivas tarefas em todas_tarefas.php



							AULA: APP LISTA DE TAREFAS - LISTANDO TODOS OS REGISTROS PARTE 2

Nessa aula vamos recuperar os dados do banco de dados e apresentar esses dados na nossa aplicação, nós vamos fazer isso através de uma lógica implementada no script tarefa_controller.php

CÓDIGO:

<?php

    	require "../../app_lista_tarefa/tarefa.model.php";
    	require "../../app_lista_tarefa/tarefa.service.php";
    	require "../../app_lista_tarefa/conexao.php";

    	$acao = isset($_GET['acao']) ? $_GET['acao'] : $acao;

    	if($acao == 'inserir'){

        		$tarefa = new Tarefa();

        		$tarefa->__set('tarefa', $_POST['tarefa']);

        		$conexao = new Conexao();

        		$tarefaService = new TarefaService($conexao, $tarefa);

        		$tarefaService->inserir();

        		header("Location: nova_tarefa.php?inclusao=1");

    	}else if($acao == 'recuperar'){
        		$tarefa = new Tarefa();
        		$conexao = new Conexao();

       		$tarefaService = new TarefaService($conexao, $tarefa);
        		$tarefas = $tarefaService->recuperar();
    	}

?>

// Criamos novas instâncias de Tarefa e Conexao para declararmos no método __construct mágico de TarefaService.

// A partir de agora, apenas acompanharei a aula digitando os códigos, só comentarei se for preciso

A parte mais legal dessa aula, foi fazer o JOIN de tabelas distintas afim de tornar as  nossas tarefas como pendentes, desse modo, foi possível entender um pouco mais o seu comportamento, com base na nossa consulta, foi possível criar objetos que continham tarefas, o status (sendo pendente ou realizado) e seus respectivos id's para cada tarefa.

Outro fato importante, mas nada de novidade, foi percorrer uma array com o foreach indicando a chave como sendo os índices e seus valores como parâmetro do foreach. Assim sendo, criamos ele a partir de tags curtas do php, e no seu escopo, adicionamos o design do front end das tarefas.
	

							AULA: APP LISTA DE TAREFAS - ATUALIZANDO REGISTROS PARTE 1
	
A partir de agors nós vamos se dedicar no desenvolvimento do recurso que irá permitir a edição de tarefas já cadastradas no banco de dados. Nós temos pela frente portanto um desafio bem interessante que será dividido em duas partes.

Nessa aula nós vamos trabalhar no front end da aplicação. A ideia é fazer com que ao clicar aqui na opção de edição de qualquer uma das tarefas, que a informação da tarefa seja substituída por um formulário que permita com que uma nova informação seja digitada e posteriormente enviada para o servidor. Então este é o foco desta aula e aí sim na próxima aula nós vamos descobrir como que nós podemos lá do lado do back end da aplicação recuperar essa informação e de fato atualizar a tarefa no banco de dados.

Conhecemos um método novo nessa aula, que podemos acessar a partir variáveis que possuem como valores, árvore DOM:

tarefa.insertBefore()

	Esse método permite fazer com que uma árvore de elementos de HTML, seja inserida dentro de um outro elemento já renderizado. Ou seja, nós vamos fazer um insert após a 	renderização da página. É um método nativo da API do DOM.
	Esse elemento espera dois parãmetros, o primeiro indica qual é a árvore de elementos que será adicionado. O segundo, indica qual que é o nó dentro do elemento selecionado que 	essa árvore de elementos será adicionada. No caso de "tarefa" não tem nenhum elemento filho, mas caso "tarefa" fosse um elemento com diversos elementos filhos, então nós precisaríamos definir como segundo parâmetro qual que é esse nó. Como "tarefa" não tem filho, pegamos novamente a sua referência e dizemos que o índice é 0, quer dizer que é o primeiro elemento filho contido dentro de tarefa.


	tarefa.insertBefore(form, tarefa[0])


							AULA: APP LISTA DE TAREFAS - ATUALIZANDO REGISTROS PARTE 2

Nessa aula vamos implementar o recurso de atualizar os registros só que agora do lado do Back End.

Uma trecho importante dessa aula maravilhosa é que quando estamos executando uma query de atualização, ou seja, update, caso a atualização seja bem executada, o retorno dessa atualização será 1, caso seja N registros atualizados, o retorno será N.

Portanto, podemos aplicar essa lógica em condicionais para melhorar a nossa aplicação, e foi o que fizemos.

EXEMPLO:

Tarefa.Service.php

        public function atualizar() { //update
            $query = "update 
                    tb_tarefas
                set 
                    tarefa = :tarefa
                where
                    id = :id";

            $stmt = $this->conexao->prepare($query);
            $stmt->bindValue(':tarefa', $this->tarefa->__get('tarefa'));
            $stmt->bindValue(':id', $this->tarefa->__get('id'));
            return $stmt->execute();
        }

É certo que True = qualquer valor superior a 0 e False = 0.

	

							AULA: EXTRA - PREPARE COM MARCADORES "?" E MÉTODO SETTERS COM RETURN $THIS

PRIMEIRA DICA

	A primeira dica está relacionada aos marcadores que podem ser utilizados do método prepare() do PDOStatement.

	MARCADORES:
	
		Quando nós efetuamos o bindValue(), nós estamos utilizando marcadores nomeados. Porém nós podemos utilizar ao invés de marcadores nomeados, o ponto de interrogação, e o bind, ou seja, a ligação será feita a partir da indicação de qual que é o ponto de interrogação que será substituido.

		Nós podemos fazer quantos pontos de interrogações forem necessários.

	POR EXEMPLO:

        		public function atualizar()
	       	{ //update
            			$query = "update 
                    			tb_tarefas
                			set 
                    			tarefa = ?
                			where
                    			id = ?";

            			$stmt = $this->conexao->prepare($query);
            			$stmt->bindValue(1, $this->tarefa->__get('tarefa'));
            			$stmt->bindValue(2, $this->tarefa->__get('id'));
            			return $stmt->execute();
        		}

SEGUNDA DICA

	A segunda dica está relacionada aos métodos Setters.

	SETTER:

		Como sabemos, os método Setters apenas colocam valores em variáveis, mas e se eles retornassem valores também, iria diminuir código, pois assim, no lugar de ficar referenciando o objeto instanciado através de uma classe que incluem setters no escopo, podemos facilitar, observe os exemplos:

	MODIFICAÇÃO NO MÉTODO SETTER:

		public function __set($atributo, $valor) {
            			$this->$atributo = $valor;
			return $this;
        		}

	SEM SETTER DE RETORNO:

		$tarefa = new Tarefa();
        		$tarefa->__set('id', $_POST['id']);
        		$tarefa->__set('tarefa', $_POST['tarefa']);

	COM SETTER DE RETORNO:

		$tarefa = new Tarefa();
        		$tarefa->__set('id', $_POST['id'])->$tarefa->__set('tarefa', $_POST['tarefa']);


							SEÇÃO: PUBLICAÇÃO DE APLICAÇÕES WEB NA INTERNET

							AULA: REFRESCANDO A MEMÓRIA SOBRE INTERNET E WEB

A internet é na verdade um meio físico de comunicação entre dispositivos conectados a essa rede. Já a web é um serviço que opera sobre a internet.

Uma vez criada a aplicação web, nós precisamos hospedar essa aplicação web em algum local. Então duas coisas surgem nesse processo que é justamente o que nós vamos estudar ao longo dessa Seção, que são os servidores de hospedagem, e o serviço de DNS, de Domain Name System, esses recursos citados, nós precisamos compreender bem para de fato conseguir hospedar as nossas aplicações web na internet.


							AULA: DNS - DOMAIN NAME SYSTEM ( SISTEMA DE NOME DE DOMÍNIO )


Esse recurso é muito importante no contexto das aplicações web na internet, porque é através dele que nós faremos a configuração da URL de acesso à nossa aplicação.

É importante ter em mente que qualquer dispositivo conectado à internet como por exemplo um tablet, um celular, notebook, um computador, uma TV, uma câmera ou uma impressora ou até mesmo uma geladeira. Todos esses dispositivos conectados à Internet recebem uma identificação única conhecida como IP e é através desse IP que nós podemos utilizar no meio físico da internet nos comunicar com esses dispositivos diretamente.

Quando a web ainda não era um serviço tão popular rodando em cima da internet nós fazíamos o acesso aos servidores HTTP através desse endereço IP que é uma combinação hierárquica de números nós utilizavamos essa numeração única e exclusiva que identificava esse computador/essa máquina na rede para consumir os seus respectivos recursos. Porém com o aumento exponencial da web utilizar essa numeração para acessar os serviços nas páginas na internet acabou se tornando algo bastante complexo. Nós na condição de humanos nos sentimos muito mais familiarizados em memorizar nomes do que sequências numéricas.

Servidores DNS nada mais são do que servidores de conversão da URL familiarizada e amigável para os seres humanos para um enderço IP. Existem centenas milhares de servidores DNS disponíveis na internet. O objetivo desses servidores é justamente converter o nome de um site para o seu respectivo endereço IP.

Então quando nós colocamos o URL no Browser, o que nós estamos fazendo no momento da requisição, na verdade, é solicitando antes o endereço IP dessa URL para algum servidor DNS. Porém, onde está esse servidor DNS ? em que momento está configurado quando nós estamos utilizando a internet para utilizar a internet ?  Você precisa de um provedor de internet, logo qualquer requisição que você faça, a partir do seu computador ou do seu dispositivo conectado à internet, essa solicitação vai passar pelo seu provedor e o seu provedor possui um servidor DNS associado, ou aponta para algum.

Quando a requisição é feita, o browser vai solicitar essa conversão de nome para endereço IP, pode ser que pode ser que o servidor DNS utilizado pelo seu provedor de internet ou que esteja configurado no seu browser, não tenha essa referência, que ele faz? ele solicita para outro e assim consecutivamente, até que em algum momento, algum servidor DNS irá literalmente resolver esse nome para nós, devolvendo o endereço de IP relativo a esse nome, com isso, o browser irá localizar a aplicação servidora na internet.



							AULA: SERVIDORES DE HOSPEDAGEM


Nessa aula, nós vamos falar um pouco sobre servidores de hospedagem.

Servidores de hospedagem são servidores http, que hospeda a nossa aplicação web.

Através da contratação de um serviço de hospedagem, você terá acesso ao servidor http, e poderá transferir os seus arquivos da aplicação web, para este servidor, que estará conectado à internet 24 horas por dia, 7 dias por semana, respondendo às requisições http, feitas para ele. e com isso, servindo a aplicação web.

Serviço de Hospedagem:

	infinityfree.net

	Com ele podemos ter um serviço de hospedagem com até 3 domínios distintos, o que significa que podemos subir até três aplicações web.

Serviço de Domínio:

	freenom.com

	Podemos encontrar nesse site domínios gratuitos!!.

							AULA: CONHECENDO O FAMOSO CPANEL

Uma das partes mais importntes nessa aula foi saber que é através do protocolo FTP que subimos os nossos arquivos da máquina local para o servidor de hospedagem.


							AULA: FILEZILLA CLIENT FTP (INSTALAÇÃO)



							SEÇÃO 18: PADRÃO DE ARQUITETURA MVC COM PHP

							AULA: INTRODUÇÃO AO PADRÃO DE ARQUITETURA MVC


Para entendermos o que é o padrão MVC (Model View Controller) precisamos saber primeiramente saber o que ele não e:

Padrão de arquitetura (Architectural Pattern)

Cliente-Servidor		Plugin				Computação distribuída
P2P			Analise de sistema estruturada		Aplicação monolítica
Quadro Negro		Arquitetura orientada a serviço		Modelo em três camadas
Criação implícita		Arquitetura orientada a busca		
Pipes e filtros		MVC

	// Quando estamos falando de padrão de arquitetura, estamos falando basicamente da forma como as funcionalidades no software serão organizadas, mas não do softwre em si.
	// A arquitetura não se preocupa com a codificação em si, mas em como os componentes estão interconectados.

Padrão de projeto (Design Pattern)

	by Gof (Ganf of Four)

Padrões de criação		Padrões estruturais			Padrões comportamentais

Abstract Factor		Adapter				Chain of Responsability
Builder			Facade				Comman
Factory Method		Bridge				Interpreter
Prototype			Decorator				Iterator
Singleton			Fly Weight			Mediator
			Composite			Memento
			Proxy				Observer

	// Quando estamos falando de padrão de projeto, estamos falando de como certas funcionalidades podem ser desenvolvidas dentro dos nossos softwares. Ou seja, estamos falando de técnicas de implementação de funcionalidades a nível de código que já foram testadas no passado e que são vistas como boas práticas.

	by GRASP - General Responsability Assignment Software Patterns (of Principies)

Controller			Information Expert			Polymorphism
Creator			High Cohesion			Protected variation
Indirection		Loose coupling			Pure fabrication

MVC é um padrão de arquitetura, ou seja, através dele, nós iremos estabelecer uma forma de organização do código, mas não necessariamente estamos falando de como programar a aplicação.

É fundamental ter em mente que tanto os padrões de arquitetura quanto os padrões de projeto, são independentes de linguagem ou tecnologia. Ou seja, são soluções já testadas que podem ser aplicadas em projetos futuros. São modelos de soluções de problemas.

No campo de desenvolvimento web, o MVC ganhou muito espaço, e atualmente é o padrão de arquitetura mais utilizado das aplicações web de modo geral, tanto que diversos frameworks implementam o padrão MVC. Funcionar em cima de uma arquitetura, não significa ter uma limitação, significa apenas que seguir certas regras estruturais e de comunicação com outras aplicações. Ou seja, a arquitetura em si, não limita a codificação, apenas cria um quadro onde a codificação deve ser estabelecida.


Em nossas aplicações que desenvolvedores programam, existe:

	REQUISITOS NÃO FUNCIONAIS

		Recursos que não estão diretamente relacionados com as funcionalidades da aplicação.

			Ex: Segurança, usubalidade, portabilidade, reusabilidade.

		** Arquitectural Pattern **

	REQUISITOS FUNCIONAIS

		Recursos da aplicação em si, ou seja, ligados diretamente às funcionalidades da aplicação.

			Ex: Requisitar pedido de usuário, verificar usuário no sistema.

		** Design Pattern **


							AULA: UM POUCO MAIS SOBRE MVC E A PREPARAÇÃO DA ESTRUTURA DO PROJETO


Nessa aula nós vamos estudar um pouco mais sobre a arquitetura MVC e vamos também começar a preparar a estrutura do nosso projeto. De modo que nós comece a ver essa arquitetura na prática.

MVC (Model View Controller)

	Controller

		Recebe todas as requisições e controla o que deve acontecer e quando

	View

		Exibição dos dados (html, xml, json)

	Model

		Camada de banco de dados e regras de negócio. É responsável pela manipulação dos dados dentro da aplicação, camada conhecida como regras de negócio.

O padrão de arquitetura MVC foi descrito pela primeira vez no final da década de 70. Ele foi utilizado inicialmente na lingugem de programação SmallTalk. Então pereceba, trata de um padrão de arquitetura desenvolvido fora do contexto de aplicações web. Porém, esse padrão de arquitetura se encaixou muito bem no contexto de aplicações web. Por isso que ele é tão difundido.

SERVIDOR PHP

Um ponto importante nessa aula, é que a partir de versões superiores a 5.4 do php, ele vem com um servidor embutido no seu software que podemos usar para manipular arquivos em php. Podemos acessar tal recurso através da linha de comando (cmd).

aplicamos o seguinte código:

	php -v
	// Esse comando só irá funcionar dentro da pasta php que está dentro de xampp, ou seja, onde o php está instalado (c:/xampp/php), isso pq esse comando não é reconhecido como um comando interno do sistema operacional. O que significa que temos que configurar esse diretório como senddo uma variável de ambiente, de modo que o sistema operacional faça o mapeamento de todos os executáveis contidos nessa pasta, e aí, seja possível de qualquer local do sistema poperacional disparar esses comandos. Para fazer isso, nos basta em: propriedades (do meu computador) -> configurações avançadas do sistema -> variáveis de ambiente -> atribuir o caminho C:\xampp\php.

	Feito isso, digite o comando em qualquer parte do sistema operacional:

	php -S localhost:8080

	Pronto, está tudo funcionando!!!

Mas porque utilizamos esse servdor, e não um já integrado ao XAMPP para fazermos as nossas aplicações?

	Porque o xampp tem uma pequena limitação, que é justamente, o document Root, nós precisaríamos organizar a nossa estrutura de diretórios, em função do diretório público do apache, que nesse caso, é o diretório htdocs, e isso iria limitar bastante o nosso desenvolvimento. Sempre quando fossemos desenvolver ou trabalhar em cima de uma aplicação nova, que implementasse o nosso miniframework, nós precisaríamos limpar todo o conteúdo de htdocs para testar essa única aplicação. Do modo em que nós estamos trabalhando agora, nada impede que nós copiamos a pasta miniframework contendo a nossa arquitetura de projeto, renomeie como sendo o nome da aplicação, e partir de uma nova instância do cmd, inicialize um novo servidor de desenvolvimento. Dessa forma, teremos duas aplicações funcionando em paralelo, sem a necessidade de ter que ficar ativando uma e reativaando outra.


A arquitetura MVC não é tudo, mas sim, uma parte da nossa aplicação, precisamos também de um sistema de gerenciamento de arquivos para fazer um auto-load de todos os arquivos distribuídos dentro dessa hierarquia, e nós precisamos também de um módulo para gerenciamento de rotas para que seja possível com base nas requisições feitas por clientes, através do protocolo HTTP, decidir quais actions sejam disparadas dentro dos nossos controllers. 


							AULA: COMPOSER E AUTOLOAD PSR-4

Dentro da estrutura MVC, para cada um do Controller, Model, e View, nós vamos criar diversas classes pra atender objetivos específicos, e naturalmente por ser scripts separados, nós precisamos juntar esses scripts, para utilizar os seus respectivos recursos.

Compser nada mais é do que um gerenciador de dependências, através do composer nós podemos facilmente trazer pacotes externos para dentro das nossas estruturas dos nossos projetos. Além disso, por ser um gerenciador de dependencias, o composer implementa um sistema de autoload. Ou seja, através do composer dentro do nosso projeto, nós podemos facilmente fazer o carregamento de todos os scripts da nossa aplicação e utilizar esses scripts de acordo com a especificação passada para esse sistema de autoload do composer, que nesse caso, nósvamos utilizar o mais recente que é a especificação mais recente do php chamado de PSR-4

Basicamente falando, o composer vai mapear toda a estrutura da nossa aplicação, vai recuperar todas as classes contidas dentro dos scripts e vai permitir o acesso à essas classes através da especificação de namespaces. Nós não vamos precisar fazendo requires a todo o momento para utilizar as classes contidas dentro do nosso projeto. Basta utilizar o namespace daquela respectiva classe  e nós temos condições de utilizá-la a qualquer momento dentro da lógica da nossa aplicação.


COMPOSER

	É possível baixá-lo e instalá-lo para que assim possamos escrever por meio da linha de comando (cmd) comandos ara manipulá-lo

	Mas também, é possível utilizar o recurso de instalação através da linha de comando. Esse processo permite baixar o composer para um projeto específico. Nós vamos portanto, trazer o composer para dentro do nosso projeto, e a partir daí, nós vamos configurar o composer especificamente para esse projeto. Vamos fazer dessa maneira:

		php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"

		Com isso, a nossa pasta escolhida ganhou um novo arquivo: composer-setup.php

		php -r "if (hash_file('sha384', 'composer-setup.php') === '55ce33d7678c5a611085589f1f3ddf8b3c52d662cd01d4ba75c0ee0459970c2200a51f492d557530c71c15d8dba01eae') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

		Esse comando verifica se a download do composer-setup foi concluido com sucesso.

		php composer-setup.php

		Esse comando executa o script de setup do composer no nosso diretório.

		Feito isso, podemos utilizar os recursos do composer através da instrução:

			php composer.phar

			Até agora o que fizemos foi permitir fazer instruções do composer no cmd, mas ele não está instalado de fato na nossa aplicação, para isso faça:

				php composer.phar install

			Antes de fazer essa instrução, é necessário configurar um novo arquivo que criamos chamado de composer.json

Na nossa aplicação é necessário ter o arquivo composer.json, isso porque vamos utilizar a instrução php composer.phar


COMPOSER.JSON CONFIGURAÇÃO:

	nome

	require (requisitos para usar o miniframework)

	autores (podemos especificar o nome e o email)

	autoload

		Esse passo é fundamental. É a definição do autoload, ou seja qual será o método utilizado pelo composer para fazer o autoload das classes do nosso projeto. Essa informação é fundamental para que seja possivel carregar todas as classes distribuidas dentro da estrutura MVC. Associamos a ele um objeto que vai definir para o composer a especificação psr-4 como sendo a forma como os arquivos serão carregados, então, nós associamos a essa especificação, os diretórios que precisam ser mapeados, quais serão os seus respectivos namespaces.

	Exemplo de uso:

		"autoload": {
        			"psr-4": {
           				"App\\": "App/",
            				"MF\\": "vendor/MF/"
        			}
    		}

		// Repare no escopo do objeto psr-4 que primeiro vem o nome dos namespaces das classes e depois os diretórios onde estão contidos os arquivos.
		// Além de realizar a instalação do composer, automaticamente será criado, dentro do nosso projeto, um novo diretório chamado vendor. Dentro dele é que serão colocados os pacotes adicionados na nossa aplicação, e uma dessas dependencias que vamos criar, será uma dependencia do nosso próprio framework, ou seja, um local a parte onde nós vamos criar recursos específicos do nosso framework para fazer a abstração de recursos tanto de controladores, quanto de modelos, quanto de views.

		Configurado o arquivo do composer, nós podemos executar a instalação com a instrução: php composer.phar install

Feito isso, temos será ggerado um arquivo chamado autoload_psr4.php contido dentro da pasta de composer (que está dentro da nova pasta chamada vendor). Esse arquivo irá possuir os diretórios mapeados com base nos nossos namespaces. Por isso, como o arquivo está apontando para esse diretório, temos que agora criá-lo, pois apenas o que fizemos foi especificar um caminho.	

Desse modo, para testarmos, podemos ir para o arquivo index.php no diretório público, e fazer um require do script autoload.php. O script autoload.php será responsável por fazer todo o carregamento automático de todas as classes contidas dentro da arquitetura do nosso projeto.


							AULA: INICIANDO A CONFIGURAÇÃO DE ROTAS DO MINIFRAMEWORK

Na aula anterior nós trabalhamos na instalação do composer e na sua configuração utilizando a especificação PSR-4.

Nessa aula, nós vamos trabalhar iniciando a configuração de rotas do nosso miniframework, repare que nós até agora estamos trabalhando nos requisitos não funcionais de uma aplicação web. Nós estamos apenas estruturando a aplicação para que ela seja cpaz de receber a arquitetura MVC. A arquitetura é muito importante dentro de um projeto, mas ela não é tudo, para que essa arquitetura funcione, nós precisamos implementar algumas coisas ao entorno dessa arquitetura, principalmente quando nós estamos falando de MVC no contexto de aplicação web.

Com isso, vamos criar nessa aula, o arquivo Route.php, que não está diretamente relacionado com a arquitetura MVC. Na verdade o sistema de roteamento funciona como uma camada.

O cliente por sua vez, pode requisitar o acesso à páginas index, o acesso à sua página contato ou o acesso a sua página Fale Conosco, e assim por diante. Ele pode solicitar diversos recursos diante da nossa aplicação, essa solicitação será interpretada pelo sistem de roteamento, que através dos controladores, fará o disparo de ações em função justamente dessas rotas.

// A especificação psr-4 espera que o script contido dentro de um determinado diretório, esteja em um namespace compatível com aquele respectivo diretório.

Criamos portanto uma classe Route no script route.php que será instanciada na página index.php, ao instanciar, você vai perceber que se parece um pouco com um caminho de um diretório, mas na verdade, essa semelhança se dá por conta do namespace App, e essa é a sua sintaxe:

	$route = new \App\Route;


FUNÇÕES NOVAS

parse_url($_SERVER['REQUEST_URI']);

	Recebe uma função, interpreta essa respectiva url e retorna os seus respectivos componentes. Podemos além desse parâmetro de URL, passar o parâmetro PHP_URL_PATH, que quando submetida para o parse_url(), a resposta de retorno será uma string relativa ao Path, ou seja, o valor contido no índice Path.

	Essa função, é importante pois ela retorna um array contendo as partes separadas da nossa url, ela separa path de querys, e assim por diante.

----------------------

As rotas que serão capturadas pelo sistema de roteamento será responsável basicamente por duas coisas:

	Definir qual será o controlador que entrará em ação.

	Definir qual será a ação dentro do controlador que será disparada em função do path.

Assim sendo, vamos definir em Route.php que, vamos criar um array que irá acionar o indexController como sendo, o seu respectivo controlador. Caso a rota solicitada pr o navegador seja a raíz, nós vamos indicar que o controlador que entrará em ação é o indexController e lá dentro, a ação disparada será a ação Index.

----------------------

Outro arquivo que iremos criar é o arquivo .htaccess, no qual temos que ter bastante atenção com a sintaxe desse arquivo. O arquivo .htaccess funciona como sendo um arquivo de parametrização do Apache, nós podemos definir alguns parâmetros nesse arquivo que serão configurados na hora de subir o serviço do Apache. Ele precisa ficar na pasta public, porque é aí onde nós inicializamos o servidor embutido do php.


							AULA: CONTROLLERS


As actions dos controladores citados na aula anterior, nada mis são do que os métodos dos controladores.

Acho melhor fazer os códigos junto com o professor, pois fica muito complexo anotar tudo isso, demandaria mais tempo. Tudo o que codificamos, aprendemos em aulas anteriores.


							AULA: VIEWS


Nessa aula nós vamos trabalha na camada de visualização do nosso miniframework.

Como sabemos, nós criamos até agora duas rotas para o nosso miniframework, a rota home, e a rota de sobre_nos. O conteúdo que aparece na tela para cada uma das rotas, é o conteúdo de view da nossa aplicação.

Dentro do diretório View, nós temos:

	index (diretório)

		Ele irá concentrar todas as views que poderão ser utilizadas dentro das action contidas em IndexController. Então qualquer exibição feita por esse controlador (IndexController) será feita a partir de alguma view que por sua vez, estará dentro do diretório index, dentro do diretório Views.

		Criamos dois arquivos dentro desse diretório, o index.phtml, e sobreNos.phtml.
		// Mas por que estamos utilizando a extensão .phtml? Porque essa é a extensão que os faeworks, geralmente aplicam para as views que combinam codificação php com 		html (nós vamos misturá-los).

-------------------------------

Uma das partes mais interessantes que eu vi nessa aula (13:07) foi pegar o nome inicial da classe dos Controladores afim de tornar o nosso terceiro método que faz o require_once do caminho desejado das views, dinâmico, é muito bonito, mas mais ainda, devemos ter o cuidado de escrevermos os diretórios ou até mesmo os scripts das views como sendo o primeiro nome das classes dos controladores.

	Mas como fazemoss isso?

	O segredo está em um método embutido do composer, para que nós possamos pegar o nome da classe desejada.

		$get_class($this);

------------------------------


Outra parte importante dessa aula, foi deixar os nossos array de $dados da classe IndexController mais dinâmico e elegante .

A ideia foi a seguinte:

	Ao invés de passar os dados como parãmetro para o método render(), nós podemos trabalhar com uma variável interna da nossa classe IndexController, que represente um objeto, de modo que seja possível, utilizar esse objeto dentro das nossas Views.

	Como usá-lo?

	Criamos o atributo private chamado $view.

	Em seguida podemos criar um método construtor que tenha em seu escopo a instância de um objeto interno do php 7 à variável $view

	public function __construct(){
		$this->view = new \stdClass();
	}

	STDCLASS()

		Classe nativa do php, através dela podemos criar objetos padrões (objetos vazios) - std vem de standard - que poderão ser dinamicamente compostos de atributos durante a lógica da nossa aplicação.


---------------------------

							SECTION: PHP 7 E MYSQL PROJETO TWITTER CLONE

							AULA: PESQUISANDO POR OUTROS USUÁRIOS


Em certo momento da aula utilizamos uma instrução SQL:

$query = "select id, nome, email from usuarios where nome like :nome";

	Achei importante anotar por causa do termo like. Utilizamos essa intrução pq queremos pesquisar alguns usuários no nosso projeto de Twitter Clone, mas como fazemos isso? Estamos utilizando uma tabela chamada usuárioss no banco de dados MySQL, isso significa que, imagine que queremos encontrar um nome, mas não sabemos o nome completo dessa pessoa, é aí que entra a proposta do 'like' que não relaciona uma determinada igual com igual, mas sim um conjunto de caracteres que também estão submetidos à uma string, O QUE QUER DIZER, QUE BASTA PESQUISAR POR LUCAS, PARA ENCONTRAR LUCAS LIMA DE SOUZA.


							AULA: SEGUINDO E DEIXANDO DE SEGUIR OUTROS USUÁRIOS

Em certo momento da aplicação, precisamos aplicar uma subconsulta dentro de outra instrução SQL, (fizemos isso, para quais usuários o cliente estava seguindo). Nesse contexto, temos :

$query = "
            select 
                u.id,
                u.nome, 
                u.email,
                (
                    select
                        count(*)
                    from
                        usuarios_seguidores as us
                    where
                        us.id_usuario = :id_usuario and us.id_usuario_seguindo = u.id
                ) as seguindo_sn
            from 
                usuarios as u
            where 
                u.nome like :nome and u.id != :id_usuario";

Essa subconsulta nos ajuda a ver quem o usuário que está logado na aplicação está seguindo. O seu retorno pode ser apenas 0 ou 1, porque só é possível seguir uma pessoa por vez.


							AULA: PAGINAÇÃO DE REGISTROS PARTE 1 - INTRODUÇÃO, LIMIT E OFFSET

Em nossas aplicações web, podemos determinar a quantidade de registros que o banco de dados irá retornar por meio de uma consulta em uma página web, e isso facilita em muito no desempenho da aplicação, o que faz com que cada página, possa receber um valor limitados de registros retornados, mas como fazemos isso?

Podemos utilizar duas propriedades interessante na instrução SQL:

	Limit

		Limita a quantidade de registros retornados de uma consulta SQL.

	offset

		Desloca o ponto de contagem de uma consulta a partir de um número específico.

					
							AULA: PAGINAÇÃO DE REGISTROS PARTE 2

PASSOS:

1 - Instanciamos uma variável com a quantidade de registros por página.

	$total_registros_pagina = 10;

2 - Instancimons uma variável com o valor de deslocamento da nossa instrução.

	$deslocamento = 0;

3 - Ajustar essa informação na nossa consulta;
	
	$this->view->tweets = $tweet->getPorPagina(limite, deslocamento);

	// Repare que vamos passar no método que possui a instrução SQL as duas variáveis que criamos.


							SECTION API COM SLIM FRAMEWORK

							AULA: O QUE IREI APRENDER? API COM SLIM FRAMEWORK

Nessa seção vamos aprender a como podemos criar uma API, que nada mais é do que permitir que TERCEIROS POSSAM ACESSAR SEU SISTEMA. Um exemplo, é o Google Maps, que fornece uma API que permite que outras pessoas usando sites ou aplicativos calculem rotas usando serviço de mapas.

Criando uma API, nós podemos permitir que outras pessoas acessem o seu sistema, seja para consultar, salvar, atualizar ou remover dados. Tudo isso de forma controlada, somente quem eu autorizar é quem utilizará a API.

							AULA: ENTENDENDO REQUISIÇÕES E API

Vamos utilizar basicamente REQUISIÇÕES HTTP

HTTP (Hypertext Transfer Protocol)

	Padronizou a comunicação entre navegadores e servidores.

Tipos de requisições

	Get - Recuperr dados no servidor

	Post - Criar dado novo no servidor

	Put - Atualizar dados no servidor

	Delete - Deletar dados no servidor

Código de status

	404 - Not found

	200 - Ok

	501 - Bad Gateway

	...

FUNCIONAMENTO DE UMA API

	API (Application Programming Interface) em português "Interface de Programação de Aplicações"

	// Basicamente é uma maneira de você interagir com outras aplicações.

UTILIZAÇÃO API

	A API fornece dados para um computador, por exemplo o facebook, para o navegador, ou ela pode fornecer os dados para o dispositível móvel como um celular.

	// Imagine que, quando clicamos numa postagem de um usuário do facebook, é feito uma requisição para a API, e assim, ela processa os devidos dados e retorna para o navegador web, os dados da postagem do usuário do facebook. Agora imagine que essa mesma API, pode fornecer as mesmas funções e dados, para o app facebook de dispositivos móveis, com isso, podemos criar uma API que responde os mais diversos dispositivos, fazendo com que, um único software responda a uma variedade grandes de dispositivos.

TIPOS DE RETORNOS API

	XML (Extensible Markup Language)

	<resultado>
		<temperatura>20</temperatura>
		<unidade>Celsus</unidade>
	</resultado>

	// Os tipos de retornos de API são padronizados, fazendo com que várias outras linguagens possam aderir essa API no seu código.

	JSON (JavaScript Object Notation)

	{"resultado":
		{
			"temperatura": 20,
			"unidade": "Celsius"
		}
	}



							AULA: ROTAS COM SLIM

Já sabemos da importância do arquivo .htaccess, ele fará com que algumas configurações de rotas do navegador sejam sobrescritas ás configurações do Apache, facilitando o acesso para as nossas APIs.

Todas as APIS possuem rotas que podemos acessar de qualuqer dispositivo. A classe que podemos utilizar para definir uma rota, consequentemente, um arquivo de retorno dessa API, é a classe App.

	$app = new \Slim\App;

EXECUTANDO API

	Para executar a API, precisamos executar o método run();
	
		$app->run();

INSTANCIANDO URL

Através do objeto $app, podemos instanciar uma nova rota para a API que quando acessada pelo browser, será retornado um JSON ou XML para que os programadores futuramente possam tratar esses respectivos dados.. Para definir rotas podemos utilizar o seguinte comando.

	$app->get('/postagens', function(){

   	 	echo "Listagem de postagens";

	} );

IDENTIFICANDO PLACEHOLDER

Imagine que, estamos desej=nvolvendo uma API para o facebook, e como cada usuário possui as suas respectivas postagens, precisamos de um identificador, podemos tratar esse identificador como sendo um ID inerente à rota, na qual, verificamos por meio da linguagem PHP e retornamos as informações em formato JSON/XML. Como fazemos isso?

	$app->get('/usuarios/{id}', function($request, $response){

   		$id = $request->getAttribute('id');

		// Verificar se ID é válido e existe no BD

    		echo "Listagem de usuários " . $id;

	} );

No primeiro parâmetro contendo a url em que se localiza a API, passamos um placeholder, e como segundo parâmetro, definimos dois objetos. O $request, (requisição em que se encontra a url), e o $response (resposta de retorno). Atribuimos à variável $id o seguinte método $request->getAttribute('id'), para recuperar o placeholder contido na url, e utilizá-lo na mensagem de saída echo. Desse modo, podemos verificar se o ID é válido e está contido no BD. Se o ID não fosse válido, eu poderia retornar um objeto JSON informando para o usuário que determinado campo é inválido. E como o usuário saberia como definir essa estrutura? Tudo isso é colocado na documentação, então quando você cria uma API, você precisa ensinar o usuário a fazer uma requisição para a sua API.

OU NA URL

Mas também podemos definir o identificador de usuário como sendo opcional. Fazemos isso através do colchetes:

	$app->get('/usuarios[/{id}]', function($request, $response){

   		$id = $request->getAttribute('id');

		// Verificar se ID é válido e existe no BD

    		echo "Listagem de usuários " . $id;

	} );

MAIS "OUS" NA URL


Imagine que queremos um arquivo de retorno da nossa api contendo todas as postagens de um determinado ano, passando o mês ou não. Repare na escrita da url:

	$app->get('/postagens[/{ano}[/{mes}]]', function($request, $response){

   		$ano = $request->getAttribute('ano');
		$mes = $request->getAttribute('mes');

		// Verificar se ID é válido e existe no BD

    		echo "Listagem de usuários Ano: " . $ano . " mês: " . $mes;

	} );

URL DINÂMICA

Agora queremos que o valor contido na url seja mais dinâmico, vamos definir que o identificador de acesso pode ser qualquer valor:

	$app->get('/lista/{itens:.*}', function($request, $response){

    		$itens = $request->getAttribute('itens');

    		// Verificar se ID é válido e existe no BD

    		echo $itens;

    		var_dump(explode("/", $itens));

	} );

	Utilizando o echo, a resposta seria:

		usuarios/Lucas/91238

	O var_dump serve para transformamos essa string num array, tornando a nossa url mais dinâmica:

		array(3) { [0]=> string(8) "usuarios" [1]=> string(5) "Lucas" [2]=> string(5) "91238" }


NOMEAR ROTAS

	$app->get('/blog/postagens/{id}', function($request, $response){
    		echo "Listar postagens para o ID";
	} )->setName("blog");

	Através do método setName() podemos definir um nome para um determinada rota.

	$app->get('/meusite', function($request, $response){

   		 $retorno = $this->get("router")->pathFor("blog", ["id" => "5"]);

    		echo $retorno;

	} );

	O método get tem outro recurso chamado $this->get("router") que recupera uma determinada rota. Podemos determinar esse caminho através da função pathFor(), como primeiro parâmetro, definimos o mesmo nome contido em setName() (blog), como segundo parâmetro passamos um array com os dados que eu quero.

AGRUPAR ROTAS

	Podemos agrupar rotas para que caso a nossa API sofra uma atualização, eu não tenha que renomear rotas por rotas manualmente. Exemplo de rotas:

		$app->get('/V1/usuarios', function()	e 	$app->get('/V2/usuarios', function(){

	Para isso utilizamos esses comandos:

	$app->group('/v1', function(){

    		$this->get('/usuarios', function(){

        			echo "Listagem de usuários";
    
   	 	} );
    
    		$this->get('/postagens', function(){
    
        			echo "Listagem de postagens";
    	
    		} );

	} );


							AULA: TIPOS DE REQUISIÇÕES

Nessa aula vamos falar principalmente da padronização PSR-7, tipos de retornos para o usuário e tipos de requisição ou verbos http, que são:

	get -> Recuperar recursos do servidor (Select)
	post -> Criar dado no servidor (Insert)
	put -> Atualizar dados no servidor (Update)
	delete -> Deletar dados do servidor (Delete)

Sintaxe de retorno da informação de acordo com o padrão psr-7:

MÉTODO GET

	$app->get('/postagens', function(Request $request, Response $response){

    		/* Escreve no corpo da resposta utilizando o padrão PSR7 */
    		$response->getBody()->write("Listagem de postagens");

    		return $response;

	} );

MÉTODO POST

Para receber os dados que estão sendo enviados para a API, utilizamos o seguinte método:

	$app->post('/usuarios/adiciona', function(Request $request, Response $response){

    		// Recupera post ($_POST)
    		$post = $request->getParsedBody();
    		$nome = $post['nome'];
    		$email = $post['email'];

    		/*
   		Salvar no banco de dados com INSERT INTO...
    		....
    		*/
    		return $response->getBody()->write("Sucesso");

	} );

	// Normalmente, quando utilizamos o método POST, pegamos esses mesmos dados que estamos recebendo por algum formulário e encaminhamos esses dados para o banco de dados e salvamos, caso ocorra tudo com êxito, retornamos uma mensagem de bem-sucedido.

MÉTODO PUT

	$app->put('/usuarios/atualiza', function(Request $request, Response $response){

    		// Recupera post ($_POST)
   		 $post = $request->getParsedBody();
		$id = $post['id'];
    		$nome = $post['nome'];
    		$email = $post['email'];


    		/*
    		Salvar no banco de dados com INSERT INTO...
    		....
    		*/
    		return $response->getBody()->write($nome . ' - ' . $email);
	} );

	Podemos receber


							AULA: SERVIÇOS E DEPENDÊNCIAS

INJEÇÃO DE DEPENDÊNCIA DO SLIM

	// Vamos criar primeiramente uma classe externa para nós utilizarmos algumas propriedades.

class Servico {


}

$servico = new Servico;

$app->get('/servico', function(Request $request, Response $response){

    var_dump($servico);

} );

	// Como visto na aula, não é possível utilizar o objeto $servico dentro da função, para que possamos fazer isso devemos usar USE.

$servico = new Servico;

$app->get('/servico', function(Request $request, Response $response) use ($servico) {

    var_dump($servico);

} );

	// Se tivermos muitas classes, teríamos que utilizar várias declarações de classes, então normalmente não utilizamos dessa maneira. NÓS UTILIZAMOS INJEÇÃO DE DEPENDÊNCIAS, mas para isso, devemos utilizar o container pimple. Fica dessa forma:

class Servico {


}

$servico = new Servico;

// O container pode ser utilizado para disponibilizar serviços a partir do objeto instanciado $app.

$container = $app->getContainer();

// Configurando o container...
// Damos o nome do objeto e instanciamos uma função anônima para instanciar a classe Servico.

$container['servico'] = function() {
	return new Servico;
}

$app->get('/servico', function(Request $request, Response $response){

	$servico = $this->get('servico');
    	var_dump($servico);

} );


CONTROLLERS COMO SERVIÇO

/* Controllers como serviço */

// Vamos ver agora uma outra maneira de obter o mesmo resultado, mas de uma maneira mais organizada sem que tivermos que criar várias funções anônimas.

$app->get('/usuario', 'Classe:metodo' );


} );


$app->run();
// Nós referenciamos uma classe e método como segundo parâmetro. Dessa maneira, nós definimos uma rota para que seja tratada dentro dessa respectiva classe.

Para fazermos dessa maneira, temos que configurar o composer.json definindo um autoload e um namespace onde ficará as classes que queremos instanciar no nosso projeto automaticamente. Dentro de composer.json:

{
    "autoload": {
        "psr-4": {
            "MyApp\\": "src/MyApp"
        }
    },
    "require": {
        "slim/slim": "3.*"
    }
}

// O importante é darmos a atenção para o autoload.
Feito isso vamos aplicar a seguinte instrução no cmd dentro da nossa pasta slim.

	php composer.phar dumpautoload
	// Isso irá tornar o autoload auomático

Desse modo podemos colocar os arquivos php dentro da pasta MyApp que poderá ser usada em index.php junto com os seus métodos:

	$app->get('/usuario', '\MyApp\controllers\Home:index' );
	// Criamos a pasta controllers, a classe Home ( com o mesmo nome do arquivo php) e por fim referencimos o método.

	$app->run();

Dentro da classe Home:

namespace MyApp\controllers;

Class Home{

    public function index($request, $response){
	return $response->write('Teste index');
    }

}

Repare que nos métodos temos que referenciarmos os objetos $request e $response. Isso porque o próprio slim ao acessar o método que definimos, passa por parâmetro o $request e o $response, por isso precisamos referenciar.

Para utilizar recursos do slim da página index.php na nossa classe basta criar um construtor, e colocamos como parâmetro o $container, e então o slim ele passa todos os valores contidos dentro de container automaticamente. Fica assim:

<?php

namespace MyApp\controllers;

Class Home{

    protected $container;

    public function __construct($container){
        $this->container = $container;
    }

    public function index($request, $response){

        $r = $this->container->get('request');
        var_dump($r);
        return $response->write('Teste index');
    }

}

?>


CONFIGURANDO AS MENSAGENS DE RETORNO EM CASO DE ERRO DO NOSSO SLIM:

- Vá até a instância de App e passe para o construtor da classe $app os seguintes valores de array:

$app = new \Slim\App([
    'settings' => [
        'displayErrorDetails' => true
    ]
]);


PODEMOS COMUNICAR CLASSES DIFERENTES ATRAVÉS DO CONTAINER:

$container = $app->getContainer();

$container['View'] = function() {
	return new MyApp\View;
};


$app->get('/usuario', '\MyApp\controllers\Home:index' );
	
$app->run();

// Declaramos a classe View dentro de container dentro de index.php
Desse modo, só nos basta acessar através da classe Home:

Class Home{

    protected $container;

    public function __construct($container){
        $this->container = $container;
    }

    public function index($request, $response){

        $view = $this->container->get('View');
        var_dump($view);
        return $response->write('Teste index');
    }

}

PODEMOS INSTANCIAR A CLASSE HOME SEM A AJUDA DO SLIM:

Até agr, o slim instanciou a classe Home para nós através dessa função:

	
	$app->get('/usuario', '\MyApp\controllers\Home:index' );
	
	$app->run();

Mas nós mesmo podemos fazer isso da seguine maneira:

	
$container = $app->getContainer();

$container['Home'] = function() {
	return new MyApp\controllers\Home(new MyApp\View) ;
};


$app->get('/usuario', 'Home:index' );
	
$app->run();

	// Repare que no construtor da classe Home, podemos passar a instância da classe View.
	// Dessa maneira, as classes irão se comunicar sem o objeto $container instanciado.

Mudamos um pouco a classe Home:

Class Home{

    //protected $container;
    protected $view;

    public function __construct($view){
        $this->view = $view;
    }

    public function index($request, $response){

        //$view= $this->container->get('View');
        var_dump($view);
        return $response->write('Teste index');
    }

}



							AULA : MIDDLEWARE, RESPOSTAS E DATABASE


		TIPOS DE RESPOSTAS:

- Cabeçalho

- Texto

- Json

- Xml

CABEÇALHO

$app->get('/header', function (Request $request, Response $response){
	
	$response->write('Esse é um retorno header');
	return $response->withHeader('allow', 'PUT')
		->withAddedHeader('Content-Length', 10);

	// Para definir o retorno de cabeçalho utilizamos o withHeader();
	// Para mais informações utilizamos o withAddedHeader();
	// Podemos definir um allow (permitir em pt-br) como sendo um 'PUT'.
	
}

Nas informações de cabeçalho podemos definir qualquer dado, até mesmo os códigos de status, 200, 404, 500, etc...

TEXTOS

Já estávamos utilizando faz tempo:

	$response->write('Esse é um retorno header');

JSON

$app->get('/json', function(Request $request, Response $response){

    return $response->withJson([
        "nome" => "Lucas Lima de Souza",
        "endereco" => "Endereco tal"
    ]);

    // Nós podemos criar o objeto Json através da função withJson passando como parâmetro a instância de um array como entendemos no php.
    // Supondo que tenhamos dados em um banco de dados, podemos retornar um array com o withJson e converter esse array em um objeto json.

} );

XML

$app->get('/xml', function(Request $request, Response $response){

    $xml = file_get_contents('arquivo');
    $response->write($xml);

    return $response->withHeader('Content-Type', 'application/xml');

    // Podemos definir o content-type de cabeçalho como sendo um arquivo xml, desse modo, o arquivo que escrevemos na aula como sendo um xml será interpretado como xml.
    // Essa mesma configuração poderia ser feita no arquivo Json, passamos para o response um texto e mudamos as configurações de cbçalho da nossa página de exibição.

} );


Para mais informações de configurações de cabeçalhos visite a página do slim -> User Guide -> The request / The response -> Header


------------------------


		MIDDLEWARE

Middlewares basicamente adicionam camadas de execução de código dentro da sua aplicação. Então você consegue por exemplo antes de executar as suas rotas, você consegue criar um middleware, que é uma camada de execução antes da execução core do seu sistema, que no nosso caso, são as rotas. 

Então podemos por exemplo criar um middleware que faz a validação ou autenticção de um usuário antes que ele consiga acessar qualquer rota.

Para adicionar um middleware é muito simples.

// Um middleware pode ser chamado a partir de uma função anônima, ou ele pode ser chamado a partir de uma classe utilizando o método mágco Invoke();

// middleware 1

$app->add( function($request, $response, $next){

// Na função anônima precisamos de três objetos, o request, o response, e o next que é o próximo middleware que vai ser executado.

    $response->write(' Inicio camada 1 + ');

// Dentro dos Middlewares temos que especificar qual é a próxima rota / middleware que será executado. Desse modo podemos verificar se um usuário é válido, se for, eu autorizo as rotas consequentemente a informação contida, se não, mensagem de retorno como usuário inválido e não autorizo as rotas.

    return $next($request, $response);

// Agr sim ele vai para a próxima execução, que é a rota que o usuário está executando

});

// Middleware 2

$app->add( function($request, $response, $next){

    $response->write(' Inicio camada 2 + ');

    return $next($request, $response);

});

$app->get('/usuarios', function(Request $request, Response $response){

    $response->write(' Ação principal usuarios ');

} );

$app->get('/postagens', function(Request $request, Response $response){

    $response->write(' Ação principal postagens ');

} );

$app->run();



A sequência de Middlewares é:

	Requisitando dados:

	middleware 2 ---->  middleware 1 ----->  App;

	Retorno de dados:

	App ---->  middleware 1 -----> middleware 2 ;


AS SAÍDAS DOS MIDDLEWARES PODEM SER FEITAS DE FORMA RECURSIVA!

$app->add( function($request, $response, $next){

    $response->write(' Inicio camada 1 + ');

    // return $next($request, $response);

    $response = $next($request, $response);

    $response->write(' + Fim camada 1 ');
    return $response;

});

O next faz com que nós avance para as rotas desejadas.

Com retorno ficará assim:

Inicio camada 1 + Ação principal postagens + Fim camada 1


--------------------------------------

		TRATAR BANCO DE DADOS

Podemos utilizar com o slim uma conexão com o banco de dados que vimos em seções anteriores. Como por exemplo o PDO, podemos fazer uma conexão normal, e em seguida, dentro das suas rotas, podemos abrir uma conexão com o banco de dados e selecionar os registros de uma tabela ou ainda permitir que o usuário adicione.

Mas podemos também utilizar uma ferramenta que é o illuminate que é um kit de ferramentas de banco de dados completo para o php. Com ele conseguimos trabalhar de forma muito mais simples com um banco de dados.

1 - Para instalá-lo precisamos utilizar uns comandos utilizando o composer no cmd na pasta slim:

- php composer.phar require illuminate/database

Feito isso já temos illuminate database no nosso projeto.

2 - A primeira que precisamos fazer é definir o namespace na página index.php do nosso projeto.

	use Illuminate\Database\Capsule\Manager as Capsule;

3 - Depois definimos o container: 

$container = $app->getContainer();
$container['db'] = function(){

    $capsule = new Capsule;

    $capsule->addConnection([
        'driver' => 'mysql',
        'host' => 'localhost',
        'database' => 'database',
        'username' => 'root',
        'password' => 'password',
        'charset' => 'utf8',
        'collation' => 'utf8_unicode_ci',
        'prefix' => '',
]);

$capsule->setAsGlobal();
$capsule->bootEloquent();

return $capsule;
};

4 - Fazer com que a instância $capsule se torne global;

	$capsule->setAsGlobal();

5 - Ferramenta para fazer a comunicação cm o banco de dados.

	$capsule->bootEloquent();

------------ Já configuramos o container. Agora temos que criar uma rota ----------------------

$app->get('/usuarios', function(Request $request, Response $response){

    $db = $this->get('db');
    $db->schema()->dropIfExists('usuarios');
    // Se a tabela usuarios estiver instanciada, nós apagamos ela. Pois eu quero garantir que ela sempre será criada.
    $db->create('usuarios', function($table));

});

Como já criamos o objeto db anteriormente, podemos acessá-lo

O método schema faz com que possamos configurar a nossa tabela.


							AULA: CRIANDO API

WEB SERVICE

	É uma aplicação utilizada na integração de sistemas e na comunicação entre aplicações diferentes.

REST E RESTFUL

	Rest (Representational State Transfer -> Transferência de Estado Representacional_

		é uma estrutura de software com um conjunto de melhores práticas denominadas constraints que são utilizadas para criar webservices.

	RESTful

		determina que seu sistema utiliza dessas práticas para se comunicar, seguindo a especificação da arquitetura.

// O Slim já utiliza essas boas práticas na criação do web service, então basicamente nós vamos envolver a nossa API utilizando o SLIM e dentro dele, ele já utiliza dessas práticas.


							AULA: FINALIZANDO ROTAS

ORM - Object Relational Mapper (Mapeador  de objeto relacional)

	Basicamente, quando você utiliza um ORM, fica muito mais fácil persistir os dados em um banco de dados, pois essa parte de montar as querys, o próprio ORM é que faz pra você. Basicamente você define o banco de dados que você quer utilizar, e você utiliza classes para persistir os dados em um banco de dados.
	Podemos usar o eloquent ORM junto com o laravel para fazer a persistência dos seus dados.

Basicamente o que fizemos para persistir dados utilizando um ORM foi:

1 - Criar um arquivo php com o nome de um tabela no banco de dados de forma singular.

2 - Criar a classe

	As classes precisam sempre ser no singular e com letra maiúscula, o próprio Model se encarrega de achar a tabela certa para esse tipos de classe.
	Se a tabela tiver palavras separadas por underline, na criação das classes colocamos tudo junto e para diferenciar uma palavra da outra colocamos letra maiúscula.

		//usuarios -> Usuario
		//carrinhos -> Carrinho
		//carrinho_compras -> CarrinhoCompra

3 - Utilizar o namespace Illuminate\Database\Eloquent\Model;

	// Esse arquivo é onde fica as principais tratativas do banco de dados, é ele que faz a mágica acontecer por meio do ORM.

4 - extender a classe Model na sua classe criada.

5 - Utilizar o método $produtos = Produto::get(); que ele irá listar todos os registros da tabela produtos.


							AULA: FINALIZANDO API

CORS - CROSS ORIGIN RESOURCE SHARING

Compartilhamento de recursos de origens cruzadas (CORS) e um mecanismo que usa cabeçalhos HTTP adicionis par gaarantir permissão de acesso a recursos de um servidor diferente do da origem da página.

Imagine que você tenha um site por exemplo jamiltondamasceno.com e esse site quer acessar uma API aqui do site api.galeria.com.br. Então o meu site jamilton damasceno quer acessar essa api.galeria.com.br, dentro desse domínio existe um API que vai me permitir fazer uma solicitação de uma determinada imagem ou ainda poderia ser um CSS ou qualquer outro recurso. No nosso caso poderia ser um objeto JSON. Então é feita uma solicitação nesse caso utilizando AJAX. Então imagine que dentro do meu site eu tenho uma chamada Ajax que faz uma solicitação de um determinado recurso para esse outro domínio. Então nós estamos fazendo uma requisição a partir desse domínio (jamilton.damasceno.com) para um outro domínio e nessa situação os navegadores têm uma limitação de segurança para que não seja possível fazer isso. Você não consegue utilizando a chamada Ajax fazer uma requisição para outro domínio sem que esse domínio, nesse caso a nossa API libere essa requisição. Normalmente quando você faz isso em APIs famosas esse processo já é feito e você não encontrará nenhum tipo de erro. Mas se você como o criador de um API não fizer essa liberação CORS não será possível fazer solicitações como essa, e nesse caso só é possível fazer solicitações para recursos dentro do próprio domínio.

E como resolver esse problema?

Basicamente nós vamos utilizar uma troca de cabeçalhos entre jamiltondamasceno.com e api.galeria.com.br para que essa comunicação aconteça corretamente. E ao fazer essa troca de cabeçalhos também é necessário fazer uma requisição do tipo Options.

Outra parte importante da aula, foi perceber que APIs não podem guardar um espaço reservado na memória do servidor para valores de SESSION, ou seja, se um usuário estiver autenticado com um determinado id na session, não tem como saber se o mesmo usuário tem acesso para consultar essa determinada API depois.

Para resolver o problema de SESSION visto em projetos anteriores utilizamos os tokens.

Nós vamos gerar um token dentro da nossa API, esse token será enviado para o cliente, e o cliente toda vez que for fazer uma requisição, nós vamos solicitar o token, e caso ele envie um token errado, nós vamos recusar a solicitação. Então ele só vai consumir os recursos da nossa API caso ele tenha um token válido.

Nós podemos criar uma rota que permite ao cliente gerar esse token. E para gerar esse token, o cliente precisa enviar alguns dados como um email ou senha para confirmar se esse usuário realmente esse cliente existe.

Biliotecas utilizadas nessa aula:

	firebase/php-jwt: https://github.com/firebase/php-jwt

		Essa biblioteca nos permite criar tokens de acesso para um respectivo usuário que consulta uma determinada api, consequentemente criamos uma chave de acesso.

			Comando a ser colocado no cmd: php composer.phar require firebase/php-jwt:^5.5

	jwt Authentication Middleware: https://github.com/tuupola/slim-jwt-auth

		Essa biblioteca faz a autenticação de um usuário em um determinado middleware utilizando o nosso token que criamos.

			Comando a ser colocado no cmd: php composer.phar require tuupola/slim-jwt-auth


							SEÇÃO 21: SASS

							AULA: INTRODUÇÃO AO SASS

SASS (Syntactically Awesome Style Sheets)

	É uma nova forma de escrever código css, podemos dize de forma grosseira que é uma forma de programar seu arquivo de estilo (css com super poderes).

Como funciona?

	O Sass funciona de forma pré-processada, quer dizer que você não irá utilizar os arquivos em produção, ele será processado para a utilização final no seu arquivo css.

O SASS É UMA EXTENSÃO DO CSS

	.sass (suportada, mas não é mais a padrão)

		$cor:  blue

		h1
			color: $cor

	.scss (sassy css) e tem como diferencial aceitar css no mesmo arquivo Sass

		$cor: blue;
	
		h1 {
			color: $cor;
		}

	Resultado final

	h1 {
		color: blue;
	}

POR QUE USAR?

Objetivo

	Velocidade e facilidade

	Separação facilitada dos arquivos (obtendo uma melhor organização)

Recursos

	Variáveis, operadores, funções internas e outros recursos

RIVAIS DO SASS (processadores css)

	{Less}

	Stylus


							AULA: CRIANDO PROJETO COM SASS

CONVERTENDO ARQUIVO SASS PARA SCSS

Para converter o arquivo sass para um arquivo scss utilizamos o código no cmd na pasta onde se encontra esse arquivo:

	sass arquivo.sass arquivo.scss

CONVERTENDO ARQUIVO SCSS PARA CSS

	sass arquivo.scss arquivo.css

FORMA MAIS FÁCIL DE CONVERTER UM ARQUIVO

	// Nessa etapa nós monitoramos o arquivo .scss e convertemos ele de forma automática para o arquivo .css

	Instrução:

		sass --watch arquivo.scss:arquivo.css

	Para parar basta pressionar Ctrl + C.

PODEMOS MONITORAR UMA PASTA INTEIRA

	sass --watch sass:css

							AULA:  ANINHAMENTO, VARIÁVEIS E INTERPOLAÇÃO

Nessa aula vamos utilizar um software do sass chamado SASS MEISTER que nos ajuda a escrever códigos online.

COMENTÁRIOS

	/* comentário normalmente */

ANINHAMENTO

#conteudo {
    background: green;
    padding: 15px;
    
    h1{
    color: black;
    }
    
    a {
        color: red;
    }
}

é a mesma coisa que  isso:

#conteudo {
    background: green;
    padding: 15px;
    
    
}

#conteudo h1{
    color: black;
}

#conteudo a{
    color: red;
}

REFERENCIANDO UM SELETOR PAI

a {
        color: red;
        
        &:hover {
        color: yellow;
        }
    
}

Resultado css

a {
        color: red; 
}

a:hover {
        color: yellow;
}

VARIÁVEIS

$variavel: valor;

	// É importante que o nome da variável seja a representação da variável:

	$cor-titulo: red;
	$tamanho-titulo: 20px;

ESCOPO DE VARIÁVEL

$cor-padrao: blue;

#rodape {
    $cor-padrao: red; // Para tornar a vartiavel $cor-padrao como global utilizamos !global.
    background-color: $cor-padrao;
}

h2 {
    color: $cor-padrao;
}

INTERPOLAÇÃO

	// Também é possível criar variáveis que contenham propriedades do css em seu valor, bem como guadar seletores css como id's e classes em variáveis.
	// Conseguimos executar essas propriedades com a interpolação.

	$classe: red;
	$color: color;

	#{$color} {
    		#{$color}: $classe;
	}
	
							AULA: FOR, WHILE, EACH, FUNÇÕES E IMPORTAÇÕES

FOR

@for $i from 1 through 3 {
	.item-#{$i} {
		background: green;
		margin-bottom: 2px;
	}
}

resultado:

.item-1 {
	background: green;
	margin-bottom: 2px;
}

.item-2 {
	background: green;
	margin-bottom: 2px;
}

.item-3 {
	background: green;
	margin-bottom: 2px;
}

WHILE

$contador: 1;

@while $contador < 5 {

	.item-#{$contador} {
		background: green;
		margin-bottom: 2px;
	}
	$contador: $contador + 1;	
}

EACH

$lista: green, yellow, red;

@each $cor in lista {

	.item-#{$contador} {
		background: $cor;
		margin-bottom: 2px;
	}
}

FUNÇÕES

$total: 12;
@function largura-coluna($coluna) {
	@return percentage($coluna/$total);
}

$resultado: largura-coluna(6);
/*
#{$resultado}
*/

resultado:

/*
50%
*/


FUNÇÕES NATIVAS:

- percentage() - retorna o valor passado por parâmetro em porcentagem.

- mix() - Mistura as cores, devemos duas cores e a porcentagem de mesclagem como terceiro parâmetro.

- darken() - Deixa a cor mais escura, passamos uma cor e uma porcentagem como segundo parâmetro.

- lighten() - Deixa a cor mais clara, passamos uma cor e uma porcentagem como segundo parâmetro.


IMPORTANDO ARQUIVOS:

Para importar arquivos .scss que você queira utilizar em outro .scss utilize como o=sendo o NOME desse arquivo _<nome_arquivo>.scss. Chamamos esses tipos de arquivos de parshels. Esses arquivos não geram uma folha de estilo.

	Geralmente os desenvolvedores colocam os nomes desses arquivos de_mixins.scss na qual apenas armazenam variáveis e funções para um outro arquivo em desenvolvimento.

Para importar os _mixin.scss e _variaveis.scss utilizamos:

	@import '<local>';
		
	exemplo:

	@import '_variaveis';
	
		// Não é necessário a extensão do arquivo nem o underline.


							AULA: MIXIN, HERANÇA E DIRETIVAS DE CONTROLE

MIXIN

@mixin titulo {
	background: green;
	padding: 10px 5px;
}

h1 {
	color: white;
	@include titulo;
}

h2 {
	color: yellow;
	@include titulo;
}

Basicamente o mixin é uma maneira de reaproveitar uma mesma estrutura que se repete várias vezes.

Podemos passar as cores por parâmetro para o mixin

@mixin titulo($cor, $cor-bg: black){	// Podemos definir um valor padrão.
	color: $cor;
	background: $cor-bg;
	padding: 10px 5px;
}

h1 {
	@include titulo(white, black);
}

h2 {
	@include titulo(black, green);
}

HERANÇA

.classe1 {
	color: red;
}

.classe2 {
	background: black;
}

.vermelho {
	@extend .classe1;
	@extend .classe2;
}

ENCADEAMENTO DE DIRETIVAS

.pai {
	color: red;
}

.filho {
	@extend .pai;
	background: black;
}

.erro {
    	@extend .filho;
    	padding: 10px;
    	border: 2px solid red;
}

resultado:

.pai, .filho, .erro {
  color: red;
}

.filho, .erro {
  background: black;
}

.erro {
  padding: 10px;
  border: 2px solid red;
}

UTILIZANDO O PORCENTAGEM (PLACEHOLDERS)

%pai {
	color: red;
}

%filho {
	@extend %pai;
	background: black;
}

.erro {
    	@extend %filho;
    	padding: 10px;
    	border: 2px solid red;
}

Resultado:

.erro {
  color: red;
}

DIRETIVAS DE CONTROLE => IF E ELSE

$cor: black;

@if($cor == green) {
	p{
		color: $cor;
	}
}@else if($cor == red) {
	p{
		color: $cor;
	}
}@else{
	color: $cor;
}

.erro {
  background: black;
}

.erro {
  padding: 10px;
  border: 2px solid red;
}




DIRETIVAS DE CONTROLE E MIXINS

@mixin tema($tema: padrao) {
	@if($tema == natal) {
		background: red;
		color: white;
	}@else if($tema == blackfriday){
		background: black;
		color: white;
	}
}
	